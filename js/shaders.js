let shaders = {};
shaders[`./shaders/abs-xy.frag`] = `/* For each texel of the sample texture, interpret the\nfirst two channels as a two-component vector and output its length.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = vec4(length(texture2D(tex, UV).xy));\n}`;
shaders[`./shaders/abs2-xy.frag`] = `/* For each texel of the sample texture, interpret the\nfirst two channels as a two-component vector and output its length squared.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nvoid main() {\n    vec2 r = texture2D(tex, UV).xy;\n    fragColor = vec4(r.x*r.x + r.y*r.y);\n}\n\n\n`;
shaders[`./shaders/add2.frag`] = `/* Add two textures together */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nvoid main() {\n    fragColor = texture2D(tex1, UV) + texture2D(tex2, UV);\n}\n`;
shaders[`./shaders/blend2colors.frag`] = `/* Take the rgb values of two different textures and combine\nthe two together.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float scale1;\nuniform sampler2D tex1;\nuniform float scale2;\nuniform sampler2D tex2;\n\nvoid main() {\n    vec3 color1 = texture2D(tex1, UV).rgb;\n    vec3 color2 = texture2D(tex2, UV).rgb;\n    fragColor = vec4(scale1*abs(color1) + scale2*abs(color2), 1.0);\n}\n\n\n`;
shaders[`./shaders/copy-flip.frag`] = `/* Copy and flip the contents of a texture to the output texture */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = texture2D(tex, vec2(UV.x, 1.0 - UV.y));\n}\n`;
shaders[`./shaders/copy.frag`] = `/* Copy the contents of a texture to the output texture */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = texture2D(tex, UV);\n}\n`;
shaders[`./shaders/domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\nReferences:\n\nWikipedia - Domain coloring\nhttps://en.wikipedia.org/wiki/Domain_coloring\n\nWikipedia - Hue\nhttps://en.wikipedia.org/wiki/Hue\n\nhttps://en.wikipedia.org/wiki/Hue#/media/File:HSV-RGB-comparison.svg\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    vec3 color = brightness*length(z2)*argumentToColor(atan(z2.y, z2.x));\n    fragColor = vec4(color, 1.0);\n}\n`;
shaders[`./shaders/fft-iter.frag`] = `/* This shadder is used to implement part of the \nCooley-Tukey iterative radix-2 FFT algorithm.\n\nReferences:\n\nWikipedia - Cooleyâ€“Tukey FFT algorithm\nhttps://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\nMathWorld Wolfram - Fast Fourier Transform:\nhttp://mathworld.wolfram.com/FastFourierTransform.html\n\nWilliam Press et al.\n12.2 Fast Fourier Transform (FFT) - in Numerical Recipes\nhttps://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf\n\n*/\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define complex2 vec4\n\nuniform sampler2D tex;\nuniform float blockSize;\nuniform bool isVertical;\nuniform float angleSign;\nuniform float size;\nuniform float scale;\n\nuniform bool useCosTable;\nuniform sampler2D cosTableTex;\n\nconst float PI = 3.141592653589793;\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\n\nfloat getValueFromCosTable(float angle) {\n    return texture2D(cosTableTex,\n                     vec2(angle/PI + 0.5/(size/2.0), 0.5)).r;\n}\n\ncomplex expI(float angle) {\n    if (!useCosTable)\n        return complex(cos(angle), sin(angle));\n    float c = getValueFromCosTable(abs(angle));\n    float s = (abs(angle) < PI/2.0)?\n        -getValueFromCosTable(abs(angle) + PI/2.0):\n        getValueFromCosTable(abs(angle) - PI/2.0);\n    return complex(c, sign(angle)*s);\n}\n\ncomplex mul(complex z, complex w) {\n    return complex(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\ncomplex2 c2C1(complex2 z, complex w) {\n    return complex2(mul(z.rg, w), mul(z.ba, w));\n}\n\ncomplex2 getOdd1(float x, float y) {\n    return (!isVertical)? texture2D(tex, vec2(x + blockSize/2.0, y)):\n                          texture2D(tex, vec2(x, y + blockSize/2.0));\n}\n\ncomplex2 getEven2(float x, float y) {\n    return (!isVertical)? texture2D(tex, vec2(x - blockSize/2.0, y)):\n                          texture2D(tex, vec2(x, y - blockSize/2.0));\n}\n\nvoid main() {\n    float val = (!isVertical)? mod(UV[0], blockSize): mod(UV[1], blockSize);\n    // even lower half\n    complex2 even1 = texture2D(tex, UV);\n    complex2 odd1 = getOdd1(UV[0], UV[1]);\n    float angle1 = angleSign*2.0*PI*(val - 0.5/size)/blockSize;\n    complex2 out1 = scale*(even1 + c2C1(odd1, expI(angle1)));\n    // odd upper half\n    complex2 even2 = getEven2(UV[0], UV[1]);\n    complex2 odd2 = texture2D(tex, UV);\n    float angle2 = angleSign*2.0*PI\n        *((val - 0.5/size) - blockSize/2.0)/blockSize;\n    complex2 out2 = scale*(even2 - c2C1(odd2, expI(angle2)));\n    fragColor = (val <= blockSize/2.0)? out1: out2;\n}\n`;
shaders[`./shaders/fftshift.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n// uniform bool isVertical;\n\n\nvoid main() {\n    float u0 = UV[0], v0 = UV[1];\n    float u = (u0 < 0.5)? u0 + 0.5: u0 - 0.5;\n    float v = (v0 < 0.5)? v0 + 0.5: v0 - 0.5;\n    fragColor = texture2D(tex, vec2(u, v));\n}`;
shaders[`./shaders/gradient3d.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nuniform int orderOfAccuracy;\n\n#define USE_TEXTURE_WRAPPING 0\n#define DIRICHLET 1\n#define DIRICHLET_MASK 2\nuniform int boundaryType;\n\nuniform sampler2D boundaryMaskTex;\n\nuniform int staggeredMode;\n\nuniform int index;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\nuniform vec3 dr; // Spartial step sizes\nuniform vec3 dimensions3D; // Dimensions of simulation\n\n#define X_ORIENTATION 0\n#define Y_ORIENTATION 1\n#define Z_ORIENTATION 2\n\n/* Table of finite difference stencils:\n\n - Fornberg, B. (1988).\n Generation of Finite Difference Formulas on Arbitrarily Spaced Grids.\n Mathematics of Computation, 51(184), 699-706.\n https://doi.org/10.1090/S0025-5718-1988-0935077-0\n\n*/\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n/* Get the boundary value, given the 2D texture coordinate\nuv and its 3D equivalent counterpart uvw. */\nvec4 boundaryValue(vec2 uv, vec3 uvw) {\n    if (boundaryType == USE_TEXTURE_WRAPPING)\n        return vec4(1.0);\n    else if (boundaryType == DIRICHLET)\n        return  (\n            uvw[0] < dr[0]/dimensions3D[0] ||\n            uvw[1] < dr[1]/dimensions3D[1] ||\n            uvw[2] < dr[2]/dimensions3D[2] ||\n            uvw[0] > (1.0 - dr[0]/dimensions3D[0]) ||\n            uvw[1] > (1.0 - dr[1]/dimensions3D[1]) ||\n            uvw[2] > (1.0 - dr[2]/dimensions3D[2]))? vec4(0.0): vec4(1.0);\n    else if (boundaryType == DIRICHLET_MASK)\n        return texture2D(boundaryMaskTex, uv);\n}\n\n/* Sample the texture at an integer number of texel units (i, j, and k)\naway from the input 3D coordinate variable centre. */\nvec3 offsetTexelCoordinate3D(vec3 centre, int i, int j, int k) {\n    return centre + vec3(float(i)*dr[0]/dimensions3D[0],\n                         float(j)*dr[1]/dimensions3D[1],\n                         float(k)*dr[2]/dimensions3D[2]);\n}\n\n/* Sample the texture tex with its boundary value at an integer number of\ntexel units away from that position given in the varying/in UV variable. \nThe integer i denotes the  offset along the 0th direction, \nj along the 1st, and k along the 2nd. */\nvec4 valueAt(sampler2D tex, int i, int j, int k) {\n    vec3 uvw = to3DTextureCoordinates(UV).xyz;\n    vec3 uvwOffset = offsetTexelCoordinate3D(uvw, i, j, k);\n    vec2 uvOffset = to2DTextureCoordinates(uvwOffset);\n    vec4 b = boundaryValue(uvOffset, uvwOffset);\n    return b*texture2D(tex, uvOffset);\n}\n\nvec4 valueAt(sampler2D tex, int orientation, int i) {\n    if (orientation == X_ORIENTATION)\n        return valueAt(tex, i, 0, 0);\n    else if (orientation == Y_ORIENTATION)\n        return valueAt(tex, 0, i, 0);\n    else\n        return valueAt(tex, 0, 0, i);\n}\n\nvec4 centredDiff(sampler2D tex, int i) {\n    vec4 b = boundaryValue(UV, to3DTextureCoordinates(UV));\n    if (staggeredMode >= 1) {\n        return b*(valueAt(tex, i, 1)\n                  - valueAt(tex, i, 0))/dr[i];\n    } else if (staggeredMode == 0) {\n        if (orderOfAccuracy >= 4)\n            return b*((1.0/12.0)*valueAt(tex, i, -2) \n                    - (2.0/3.0)*valueAt(tex, i, -1)\n                    + (2.0/3.0)*valueAt(tex, i, 1)\n                    - (1.0/12.0)*valueAt(tex, i, 2)\n                   )/dr[i];\n        else\n            return 0.5*b*(valueAt(tex, i, 1)\n                          - valueAt(tex, i, -1))/dr[i];\n    } else if (staggeredMode <= -1) {\n        return b*(valueAt(tex, i, 0)\n                  - valueAt(tex, i, -1))/dr[i];\n    }\n}\n\n\n/* vec4 centredXDiff(sampler2D tex) {\n    // The destination texture is staggered foward relative to the source\n    // texture\n    if (staggeredMode >= 1) {\n    } else if (staggeredMode == 0) {\n        if (orderOfAccuracy >= 4)\n            return (  (1.0/12.0)*valueAt(tex, -2, 0, 0)\n                    - (2.0/3.0)*valueAt(tex, -1, 0, 0)\n                    + (2.0/3.0)*valueAt(tex,  1, 0, 0)\n                    - (1.0/12.0)*valueAt(tex,  2, 0, 0)\n                )/dr.x;\n        else\n            return 0.5*(valueAt(tex, 1, 0, 0) - valueAt(tex, -1, 0, 0))/dr.x;\n    } else if (staggeredMode <= -1) {\n\n    }\n}\n\nvec4 centredYDiff(sampler2D tex) {\n    if (orderOfAccuracy >= 4)\n        return (  (1.0/12.0)*valueAt(tex, 0, -2, 0)\n                - (2.0/3.0)*valueAt(tex, 0, -1, 0)\n                + (2.0/3.0)*valueAt(tex, 0,  1, 0)\n                - (1.0/12.0)*valueAt(tex, 0,  2, 0)\n               )/dr.y;\n    else\n        return 0.5*(valueAt(tex, 0, 1, 0) - valueAt(tex, 0, -1, 0))/dr.y;\n}\n\nvec4 centredZDiff(sampler2D tex) {\n    if (orderOfAccuracy >= 4)\n        return (  (1.0/12.0)*valueAt(tex, 0, 0, -2)\n                - (2.0/3.0)*valueAt(tex, 0, 0, -1)\n                + (2.0/3.0)*valueAt(tex, 0, 0,  1)\n                - (1.0/12.0)*valueAt(tex, 0, 0,  2)\n               )/dr.z;\n    else\n        return 0.5*(valueAt(tex, 0, 0, 1) - valueAt(tex, 0, 0, -1))/dr.z;\n}*/\n\nvoid main() {\n    vec4 dTexdx = centredDiff(tex, X_ORIENTATION);\n    vec4 dTexdy = centredDiff(tex, Y_ORIENTATION);\n    vec4 dTexdz = centredDiff(tex, Z_ORIENTATION);\n    fragColor = vec4(dTexdx[index], dTexdy[index], dTexdz[index], 1.0); \n}\n`;
shaders[`./shaders/gray-scale.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\n\nvoid main() {\n    vec3 color = vec3(texture2D(tex, UV)[0] + offset);\n    fragColor = vec4(min(brightness*color, maxBrightness), 1.0);\n}\n\n`;
shaders[`./shaders/rev-bit-sort2.frag`] = `/* Reverse bit sort a texture whose width and height must be a power\nof two.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform int width;\nuniform int height;\n\nbool revBitSort2SingleIter(inout int rev, inout int i,\n                           inout int asc, inout int des, int stop) {\n    if (i/des > 0) {\n        rev += asc;\n	i -= des;\n    }\n    des /= 2, asc *= 2;\n    if (asc == 2*stop)\n        return false;\n    return true;\n}\n\n/* Older versions of GLSL do not support for loops.\n This very long function reverse bit sorts a finite-sized\n input texture with power of two dimensions without using any for loops.\n For more more modern versions of GLSL a different implementation of reverse\n bit sorting which uses for loops is used instead.\n*/\nvec2 revBitSort2NoForLoop(vec2 uv) {\n    vec2 uv2 = vec2(0.0, 0.0);\n    int indexU = int(floor(uv[0]*float(width)));\n    int indexV = int(floor(uv[1]*float(height)));\n \n    int rev = 0, i = indexU;\n    int asc = 1, des = width/2;\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n\n    rev = 0, i = indexV;\n    asc = 1, des = height/2;\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n\n    return uv2;\n}\n\nvec2 revBitSort2(vec2 uv) {\n    #if (!defined(GL_ES) && __VERSION__ >= 120) || (defined(GL_ES) && __VERSION__ > 300)\n    vec2 uv2 = vec2(0.0, 0.0);\n    int indexU = int(floor(uv[0]*float(width)));\n    int indexV = int(floor(uv[1]*float(height)));\n    int rev = 0, i = indexU;\n    for (int asc = 1, des = width/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uv2[0] = (float(rev) + 0.5)/float(width);\n    rev = 0, i = indexV;\n    for (int asc = 1, des = height/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uv2[1] = (float(rev) + 0.5)/float(height);\n    return uv2;\n    #else\n    return revBitSort2NoForLoop(uv);\n    #endif\n}\n\nvoid main() {\n     fragColor = texture2D(tex, revBitSort2(UV));\n}\n`;
shaders[`./shaders/scale.frag`] = `/* Scale a texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float scale;\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = scale*texture2D(tex, UV);\n}\n`;
shaders[`./shaders/sketch-potential.frag`] = `/* Shader for sketching a potential */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform vec2 location;\nuniform float amplitude;\nuniform vec2 sigmaXY;\n\nvoid main() {\n    complex oldVal = texture2D(tex, UV).xy;\n    float x0 = location.x;\n    float y0 = location.y;\n    float sigmaX = sigmaXY[0];\n    float sigmaY = sigmaXY[1];\n    float x = UV.x;\n    float y = UV.y;\n    float gx = exp(-0.5*(x - x0)*(x - x0)/(sigmaX*sigmaX));\n    float gy = exp(-0.5*(y - y0)*(y - y0)/(sigmaY*sigmaY));\n    complex newVal = oldVal + amplitude*complex(gx*gy, 0.0);\n    if (newVal.x > 2.0)\n        newVal.x = (oldVal.x < 2.0)? 2.0: oldVal.x;\n    if (newVal.x < 0.0)\n        newVal.x = (oldVal.x > 0.0)? 0.0: oldVal.x; \n    fragColor = vec4(newVal, newVal);\n\n}\n`;
shaders[`./shaders/split-step-kinetic.frag`] = `/* GLSL implementation of the momentum step for the split operator algorithm\n\nReferences:\n\nSplit-Operator Method:\nJames Schloss. The Split Operator Method - Arcane Algorithm Archive.\nhttps://www.algorithm-archive.org/contents/split-operator_method/\n split-operator_method.html\n*/\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform int numberOfDimensions;\nuniform ivec2 texelDimensions2D;\nuniform vec2 dimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\n\n#define complex vec2\n#define complex2 vec4\n\nconst float PI = 3.141592653589793;\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\nuniform complex dt;\nuniform float m;\nuniform float hbar;\nuniform sampler2D psiTex;\nuniform bool useCustomKETex;\nuniform sampler2D customKETex;\n\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\ncomplex mul(complex z, float r) {\n    return r*z;\n}\n\ncomplex mul(float r, complex z) {\n    return mul(z, r);\n}\n\ncomplex mul(complex z1, complex z2) {\n    return complex(z1.x*z2.x - z1.y*z2.y, \n                   z1.x*z2.y + z1.y*z2.x);\n}\n\ncomplex expC(complex z) {\n    return complex(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));\n}\n\nvec3 getMomentum() {\n    float u, v, w;\n    float width, height, length_;\n    int texelWidth, texelHeight, texelLength;\n    if (numberOfDimensions == 3) {\n        width = dimensions3D[0];\n        height = dimensions3D[1];\n        length_ = dimensions3D[2];\n        texelWidth = texelDimensions3D[0];\n        texelHeight = texelDimensions3D[1];\n        texelLength = texelDimensions3D[2];\n        vec3 uvw = to3DTextureCoordinates(UV);\n        u = uvw[0], v = uvw[1], w = uvw[2];\n    } else {\n        width = dimensions2D[0];\n        height = dimensions2D[1];\n        length_ = 0.0;\n        texelWidth = texelDimensions2D[0];\n        texelHeight = texelDimensions2D[1];\n        texelLength = 0;\n        u = UV[0], v = UV[1], w = 0.0;\n    }\n    float freqU = ((u < 0.5)? u: -1.0 + u)*float(texelWidth) - 0.5;\n    float freqV = ((v < 0.5)? v: -1.0 + v)*float(texelHeight) - 0.5;\n    float freqW = ((w < 0.5)? w: -1.0 + w)*float(texelLength) - 0.5;\n    return vec3(2.0*PI*freqU/width, 2.0*PI*freqV/height, \n                (numberOfDimensions == 3)? 2.0*PI*freqW/length_: 0.0);\n}\n\nvoid main() {\n    complex2 psi = texture2D(psiTex, UV);\n    complex psi1 = psi.xy;\n    complex psi2 = psi.zw;\n    complex idt = mul(IMAG_UNIT, dt);\n    if (useCustomKETex) {\n        complex kineticEnergy = texture2D(customKETex, UV).xy;\n        fragColor = vec4(mul(expC(-mul(idt, kineticEnergy)/hbar), psi1),\n                         mul(expC(-mul(idt, kineticEnergy)/hbar), psi2));\n    } else {\n        vec3 p = getMomentum();\n        float p2 = p.x*p.x + p.y*p.y + p.z*p.z;\n        fragColor = vec4(mul(expC(-idt*p2/(2.0*m*hbar)), psi1),\n                         mul(expC(-idt*p2/(2.0*m*hbar)), psi2));\n    }\n\n}`;
shaders[`./shaders/split-step-spatial.frag`] = `/* GLSL implementation of the spatial step \n(that exponential term which only depends on position)\n for the split operator algorithm\n\nReferences:\n\nSplit-Operator Method:\nJames Schloss. The Split Operator Method - Arcane Algorithm Archive.\nhttps://www.algorithm-archive.org/contents/split-operator_method/\n split-operator_method.html\n \n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define complex2 vec4\n\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\nuniform complex dt;\nuniform float m;\nuniform float hbar;\nuniform sampler2D potentialTex;\nuniform sampler2D psiTex;\n\n\ncomplex mul(complex z1, complex z2) {\n    return complex(z1.x*z2.x - z1.y*z2.y, \n                   z1.x*z2.y + z1.y*z2.x);\n}\n\ncomplex expC(complex z) {\n    return complex(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));\n}\n\n\nvoid main() {\n    complex2 psi = texture2D(psiTex, UV);\n    complex psi1 = psi.xy;\n    complex psi2 = psi.zw;\n    complex potential = texture2D(potentialTex, UV).xy;\n    complex iVdt = mul(IMAG_UNIT, mul(potential, dt));\n    if (potential.x == 0.0 && potential.y == 0.0) {\n        fragColor = vec4(psi1, psi2);\n    } else {\n        fragColor = vec4(mul(expC(-iVdt/hbar), psi1),\n                        mul(expC(-iVdt/hbar), psi2));\n    }\n}\n`;
shaders[`./shaders/surface-domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\nvarying vec3 NORMAL;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nin vec3 NORMAL;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    float ambient = 0.01;\n    // float diffuse = abs(dot(NORMAL, vec3(0.0, 0.0, -1.0)));\n    float brightness2 = brightness*length(z2);\n    vec3 color = ambient \n        + (\n            1.0 // + diffuse\n        )*brightness2*argumentToColor(atan(z2.y, z2.x));\n    fragColor = vec4(color, 1.0);\n}\n`;
shaders[`./shaders/surface-single-color.frag`] = `/* Output a single colour for every texel of the output texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\nvarying vec3 FINAL_VERTEX_POSITION;\nvarying vec3 NORMAL;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nin vec3 NORMAL;\nin vec3 FINAL_VERTEX_POSITION;\nout vec4 fragColor;\n#endif\n\nuniform vec4 color;\n\nvoid main() {\n    vec3 lightSourceLoc = vec3(0.0, 0.0, -3.0);\n    vec3 vertexToLightSource = lightSourceLoc - FINAL_VERTEX_POSITION;\n    float diffuse1 = max(dot(NORMAL, normalize(vertexToLightSource)), 0.0);\n    float diffuse2 =  max(dot(-NORMAL, normalize(vertexToLightSource)), 0.0);\n    // float diffuse2 = max(0.5*dot(NORMAL, vec3(0.0, 0.0, -1.0)), 0.0); \n    float diffuse = ((NORMAL.z < 0.0)? diffuse1: diffuse2);\n    fragColor = vec4(color.rgb*(diffuse), color.a);\n}\n`;
shaders[`./shaders/surface-vert.vert`] = ` \n#if __VERSION__ <= 120\nattribute vec2 position;\nvarying vec2 UV;\nvarying vec3 FINAL_VERTEX_POSITION;\nvarying vec3 NORMAL;\n#else\nin vec2 position;\nout vec2 UV;\nout vec3 FINAL_VERTEX_POSITION;\nout vec3 NORMAL;\n#endif\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n\n#define quaternion vec4\n\nuniform sampler2D heightTex;\nuniform quaternion rotation;\nuniform vec3 translate;\nuniform float heightScale;\nuniform float scale;\nuniform ivec2 dimensions2D;\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion q) {\n    return quaternion(-q.x, -q.y, -q.z, q.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    return quaternion(mul(conj(r), mul(x, r)).xyz, 1.0);\n}\n\nvec4 project(vec4 x) {\n    vec4 y;\n    y[0] = x[0]*5.0/(x[2] + 5.0);\n    y[1] = x[1]*5.0/(x[2] + 5.0);\n    y[2] = x[2]/5.0;\n    y[3] = 1.0;\n    return y;\n}\n\nvec3 getNormal(vec2 xy) {\n    float x = xy[0], y = xy[1];\n    float dx = 1.0/float(dimensions2D[0]);\n    float dy = 1.0/float(dimensions2D[1]);\n    float height = heightScale*texture2D(\n        heightTex, xy)[0];\n    float heightR = heightScale*texture2D(\n        heightTex, xy + vec2(dx, 0.0))[0];\n    float heightU = heightScale*texture2D(\n        heightTex, xy + vec2(0.0, dy))[0];\n    vec3 vC = vec3(x, y, height);\n    vec3 vR = vec3(x + dx, y, heightR);\n    vec3 vU = vec3(x, y + dy, heightU);\n    vec3 eU = vU - vC;\n    vec3 eR = vR - vC;\n    /* Note that since the z-axis points away from the screen,\n    and that the surface height map is inverted in the other direction,\n    these normal vectors point into the surface instead of away.\n    */\n    return normalize(mul(quaternion(eR, 0.0), quaternion(eU, 0.0)).xyz);\n}\n\n\nvoid main() {\n    UV = position;\n    float height = texture2D(heightTex, UV)[0];\n    vec4 position2 = scale*(vec4(UV - vec2(0.5, 0.5), 0.0, 0.0) \n                            + vec4(0.0, 0.0, -heightScale*height, 0.0));\n\n    // vec4 finalPosition = vec4(position2.xyz, 1.0);\n    vec4 finalPosition = rotate(position2, rotation) + vec4(translate, 0.0);\n\n    NORMAL = rotate(quaternion(-getNormal(UV), 1.0), conj(rotation)).xyz;\n    FINAL_VERTEX_POSITION = finalPosition.xyz;\n    gl_Position = project(finalPosition);\n}   `;
shaders[`./shaders/vol-render-display.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform vec4 rotation;\nuniform sampler2D gradientTex;\nuniform sampler2D densityTex;\n\nuniform ivec3 fragmentTexelDimensions3D;\nuniform ivec2 fragmentTexelDimensions2D;\n\n/* The variable UV from the previous shader contains \nthe 2D texture coordinate representation of the volume render.\nIt is 2D so that the gradient and density uniform textures are\nproperly sampled. These sampled gradient and density data points are used\ntogether to determine how the pixel should be displayed.\n\nThis corresponds to the shading step as given on the Wikipedia\npage for Volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = fragmentTexelDimensions2D[0];\n    int height2D = fragmentTexelDimensions2D[1];\n    int width3D = fragmentTexelDimensions3D[0];\n    int height3D = fragmentTexelDimensions3D[1];\n    int length3D = fragmentTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = fragmentTexelDimensions3D[0];\n    int height3D = fragmentTexelDimensions3D[1];\n    int length3D = fragmentTexelDimensions3D[2];\n    int width2D = fragmentTexelDimensions2D[0];\n    int height2D = fragmentTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n\n// void main() {\n//     vec3 r = to3DTextureCoordinates(UV);\n//     vec2 uv2 = to2DTextureCoordinates(r);\n//     fragColor = vec4(r.z, r.z, r.z, length(r));\n// }\n\n\nvoid main() {\n    vec3 r = to3DTextureCoordinates(UV);\n    vec2 uv2 = to2DTextureCoordinates(r);\n    vec3 normal = rotate(quaternion(0.0, 0.0, 1.0, 1.0),\n                         conj(rotation)).xyz;\n    vec3 grad = texture2D(gradientTex, uv2).xyz;\n    vec4 density = texture2D(densityTex, uv2);\n    vec4 pix = density;\n    ivec3 texelDimensions3D = fragmentTexelDimensions3D;\n    float dx = 1.0/float(texelDimensions3D[0]);\n    float dy = 1.0/float(texelDimensions3D[1]);\n    float dz = 1.0/float(texelDimensions3D[2]);\n    /* vec2 zF = to2DTextureCoordinates(vec3(r.x, r.y, r.z + dz));\n    vec2 zB = to2DTextureCoordinates(vec3(r.x, r.y, r.z - dz));\n    vec2 xF = to2DTextureCoordinates(vec3(r.x + dx, r.y, r.z));\n    vec2 xB = to2DTextureCoordinates(vec3(r.x - dx, r.y, r.z));\n    vec2 yF = to2DTextureCoordinates(vec3(r.x, r.y + dy, r.z));\n    vec2 yB = to2DTextureCoordinates(vec3(r.x, r.y - dy, r.z));\n    density = (texture2D(densityTex, zF)\n                 + texture2D(densityTex, zB)\n                 + texture2D(densityTex, xF)\n                 + texture2D(densityTex, xB)\n                + texture2D(densityTex, yF)\n                + texture2D(densityTex, yB)\n                 + density);*/\n    // pix.a = pix.b;\n    // lf (length(grad) < 0.0000001) discard;\n    if (pix.a < 0.05) discard;\n    if (dot(grad, grad) == 0.0) discard;\n    // fragColor = 4.0*pix;\n    float a = dot(normal, normalize(grad));\n    if (a <= 0.0) discard;\n    fragColor = vec4(normalize(density.rgb), 0.1*a);\n    // fragColor = vec4(1.0);\n}`;
shaders[`./shaders/vol-render-display.vert`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nattribute vec2 uvIndex;\nvarying vec2 UV;\n#else\nin vec2 uvIndex;\nout vec2 UV;\n#endif\n\n#define quaternion vec4\n\nuniform vec4 debugRotation;\nuniform bool debugShow2DTexture;\nuniform float scale;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\n/* The attribute or input uvIndex contains the 2D coordinates represetation\nof the volume render frame, which is then converted to 3D coordinates\nand manipulated using the other uniforms.\nIt is also directly passed to the fragment shader as the varying or\nout variable UV, so that it can be used to sample the volume data which\nis store in the 2D texture format.\n*/\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec4 project(vec4 x) {\n    return vec4(x.x, x.y, x.z, 1.0);\n    /* vec4 y;\n    y[0] = x[0]*5.0/(x[2] + 5.0);\n    y[1] = x[1]*5.0/(x[2] + 5.0);\n    y[2] = x[2];\n    y[3] = 1.0;\n    return y;*/\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    if (debugShow2DTexture) {\n        gl_Position = vec4(2.0*(uvIndex - vec2(0.5, 0.5)), 0.0, 1.0);\n        return;\n    }\n    UV = uvIndex.xy;\n    // float scaleAdj = min(scale, 2.0);\n    vec4 viewPos = vec4(to3DTextureCoordinates(UV), 1.0)\n                   - vec4(0.5, 0.5, 0.5, 0.0);\n    gl_Position = project(2.0*rotate(viewPos, debugRotation));\n}\n`;
shaders[`./shaders/vol-render-sample-display.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform float viewScale;\n\nuniform vec4 rotation;\nuniform sampler2D gradientTex;\nuniform sampler2D densityTex;\n\nuniform ivec3 sampleTexelDimensions3D;\nuniform ivec2 sampleTexelDimensions2D;\nuniform ivec3 viewTexelDimensions3D;\nuniform ivec2 viewTexelDimensions2D;\n\n/* The variable UV from the previous shader contains \nthe 2D texture coordinate representation of the volume render.\nIt is 2D so that the gradient and density uniform textures are\nproperly sampled. These sampled gradient and density data points are used\ntogether to determine how the pixel should be displayed.\n\nThis corresponds to the shading step as given on the Wikipedia\npage for Volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\n/* Sample and interpolate data points from the texture containing the \ninitial raw 3D volumetric data to points on volume render frame.\nThis corresponds to the sampling step given in the Wikipedia page\nfor volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nvec2 to2DSampleTextureCoordinates(vec3 uvw) {\n    int width2D = sampleTexelDimensions2D[0];\n    int height2D = sampleTexelDimensions2D[1];\n    int width3D = sampleTexelDimensions3D[0];\n    int height3D = sampleTexelDimensions3D[1];\n    int length3D = sampleTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(sampleTexelDimensions3D[0]);\n    float height3D = float(sampleTexelDimensions3D[1]);\n    float length3D = float(sampleTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DSampleTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DSampleTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DSampleTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DSampleTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DSampleTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DSampleTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DSampleTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DSampleTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = viewTexelDimensions3D[0];\n    int height3D = viewTexelDimensions3D[1];\n    int length3D = viewTexelDimensions3D[2];\n    int width2D = viewTexelDimensions2D[0];\n    int height2D = viewTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n\nvoid main() {\n    // float viewScaleAdj = max(viewScale, 2.0);\n    vec3 r = to3DTextureCoordinates(UV);\n    vec3 rSampler = rotate(quaternion(r - vec3(0.5), 1.0), \n                           conj(rotation)).xyz/viewScale + vec3(0.5);\n\n    // This check needs to be done to avoid a repeating effect\n    // caused by sampling beyond the initial boundary.\n    if (rSampler.x < 0.0 || rSampler.x >= 1.0 ||\n        rSampler.y < 0.0 || rSampler.y >= 1.0 ||\n        rSampler.z < 0.0 || rSampler.z >= 1.0) \n        discard;\n\n    vec3 grad = sample2DTextureAs3D(gradientTex, rSampler).xyz;\n    vec4 density = sample2DTextureAs3D(densityTex, rSampler);\n    if (density.a < 0.05)\n        discard;\n    if (dot(grad, grad) == 0.0)\n        discard;\n\n    vec3 normal = rotate(quaternion(0.0, 0.0, 1.0, 1.0),\n                         conj(rotation)).xyz;\n    float a = dot(normal, normalize(grad));\n    if (a <= 0.0)\n        discard;\n    fragColor = vec4(normalize(density.rgb), 0.1*a);\n}`;
shaders[`./shaders/vol-render-sample.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform sampler2D tex;\nuniform float viewScale;\nuniform vec4 rotation;\nuniform ivec3 renderTexelDimensions3D;\nuniform ivec2 renderTexelDimensions2D;\nuniform ivec3 sampleTexelDimensions3D;\nuniform ivec2 sampleTexelDimensions2D;\n\n/* Sample and interpolate data points from the texture containing the \ninitial raw 3D volumetric data to points on volume render frame.\nThis corresponds to the sampling step given in the Wikipedia page\nfor volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return vec4(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec2 to2DSampleTextureCoordinates(vec3 uvw) {\n    int width2D = sampleTexelDimensions2D[0];\n    int height2D = sampleTexelDimensions2D[1];\n    int width3D = sampleTexelDimensions3D[0];\n    int height3D = sampleTexelDimensions3D[1];\n    int length3D = sampleTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DRenderTextureCoordinates(vec2 uv) {\n    int width3D = renderTexelDimensions3D[0];\n    int height3D = renderTexelDimensions3D[1];\n    int length3D = renderTexelDimensions3D[2];\n    int width2D = renderTexelDimensions2D[0];\n    int height2D = renderTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(sampleTexelDimensions3D[0]);\n    float height3D = float(sampleTexelDimensions3D[1]);\n    float length3D = float(sampleTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DSampleTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DSampleTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DSampleTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DSampleTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DSampleTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DSampleTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DSampleTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DSampleTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvoid main() {\n    vec4 viewPosition \n        = vec4(to3DRenderTextureCoordinates(UV) - vec3(0.5), 1.0);\n    // float viewScaleAdj = max(viewScale, 2.0);\n    float viewScaleAdj = viewScale;\n    vec3 r = rotate(viewPosition, conj(rotation)).xyz/viewScaleAdj\n         + vec3(0.5);\n    // This check needs to be done to avoid a repeating effect\n    // caused by sampling beyond the initial boundary.\n    if (r.x < 0.0 || r.x >= 1.0 ||\n        r.y < 0.0 || r.y >= 1.0 ||\n        r.z < 0.0 || r.z >= 1.0) discard;\n    fragColor = sample2DTextureAs3D(tex, r);\n    // fragColor = vec4(1.0);\n}\n`;
shaders[`./shaders/wavepacket.frag`] = `/* Generate a new wavepacket. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\ncomplex mul(complex a, complex b) {\n    return complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// wave number of the wave packet (w.r.t. simulation domains)\nuniform vec2 waveNumber;\n// Position Offset of the wave packet in texture coordinates\nuniform vec2 texOffset;\n// Amplitude of the wave packet\nuniform float amplitude;\n// Standard deviation of the wave packet, in texture coordinates\nuniform vec2 sigmaXY;\n\ncomplex wavepacket(vec2 r) {\n    float sx = sigmaXY.x;\n    float sy = sigmaXY.y;\n    float gx = exp(-0.25*pow(r.x/sx, 2.0))/sqrt(sx*sqrt(2.0*PI));\n    float gy = exp(-0.25*pow(r.y/sy, 2.0))/sqrt(sy*sqrt(2.0*PI));\n    float g = gx*gy;\n    float nx = waveNumber.x;\n    float ny = waveNumber.y;\n    complex phase = complex(cos(2.0*PI*(nx*r.x + ny*r.y)),\n                            sin(2.0*PI*(nx*r.x + ny*r.y)));\n    return amplitude*g*phase;\n}\n\nvoid main() {\n    float x = UV.x;\n    float y = UV.y;\n    float x0 = texOffset.x;\n    float y0 = texOffset.y;\n    vec2 r = vec2(x - x0, y - y0);\n    complex w = wavepacket(r)\n        + wavepacket(vec2(r.x + 1.0, r.y)) \n        + wavepacket(vec2(r.x - 1.0, r.y)) \n        + wavepacket(vec2(r.x, r.y + 1.0))\n        + wavepacket(vec2(r.x, r.y - 1.0))\n        + wavepacket(vec2(r.x - 1.0, r.y - 1.0))\n        + wavepacket(vec2(r.x + 1.0, r.y + 1.0))\n        + wavepacket(vec2(r.x + 1.0, r.y - 1.0))\n        + wavepacket(vec2(r.x - 1.0, r.y + 1.0));\n    fragColor = vec4(w, w);\n}\n`;
const SHADERS = shaders;
export default SHADERS;
export const getShader = name => {console.log(`Getting ${name}.`); return SHADERS[name];}
