let shaders = {};
shaders[`./shaders/abs-xy.frag`] = `/* For each texel of the sample texture, interpret the\nfirst two channels as a two-component vector and output its length.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = vec4(length(texture2D(tex, UV).xy));\n}`;
shaders[`./shaders/abs2-xy.frag`] = `/* For each texel of the sample texture, interpret the\nfirst two channels as a two-component vector and output its length squared.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nvoid main() {\n    vec2 r = texture2D(tex, UV).xy;\n    fragColor = vec4(r.x*r.x + r.y*r.y);\n}\n\n\n`;
shaders[`./shaders/add2.frag`] = `/* Add two textures together */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nvoid main() {\n    fragColor = texture2D(tex1, UV) + texture2D(tex2, UV);\n}\n`;
shaders[`./shaders/blend2colors.frag`] = `/* Take the rgb values of two different textures and combine\nthe two together.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float scale1;\nuniform sampler2D tex1;\nuniform float scale2;\nuniform sampler2D tex2;\n\nvoid main() {\n    vec3 color1 = texture2D(tex1, UV).rgb;\n    vec3 color2 = texture2D(tex2, UV).rgb;\n    fragColor = vec4(scale1*abs(color1) + scale2*abs(color2), 1.0);\n}\n\n\n`;
shaders[`./shaders/copy.frag`] = `/* Copy the contents of a texture to the output texture */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = texture2D(tex, UV);\n}\n`;
shaders[`./shaders/domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\nReferences:\n\nWikipedia - Domain coloring\nhttps://en.wikipedia.org/wiki/Domain_coloring\n\nWikipedia - Hue\nhttps://en.wikipedia.org/wiki/Hue\n\nhttps://en.wikipedia.org/wiki/Hue#/media/File:HSV-RGB-comparison.svg\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    vec3 color = brightness*length(z2)*argumentToColor(atan(z2.y, z2.x));\n    fragColor = vec4(color, 1.0);\n}\n`;
shaders[`./shaders/fft-iter.frag`] = `/* This shadder is used to implement part of the \nCooley-Tukey iterative radix-2 FFT algorithm.\n\nReferences:\n\nWikipedia - Cooleyâ€“Tukey FFT algorithm\nhttps://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\nMathWorld Wolfram - Fast Fourier Transform:\nhttp://mathworld.wolfram.com/FastFourierTransform.html\n\nWilliam Press et al.\n12.2 Fast Fourier Transform (FFT) - in Numerical Recipes\nhttps://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf\n\n*/\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define complex2 vec4\n\nuniform sampler2D tex;\nuniform float blockSize;\nuniform bool isVertical;\nuniform float angleSign;\nuniform float size;\nuniform float scale;\n\nuniform bool useCosTable;\nuniform sampler2D cosTableTex;\n\nconst float PI = 3.141592653589793;\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\n\nfloat getValueFromCosTable(float angle) {\n    return texture2D(cosTableTex,\n                     vec2(angle/PI + 0.5/(size/2.0), 0.5)).r;\n}\n\ncomplex expI(float angle) {\n    if (!useCosTable)\n        return complex(cos(angle), sin(angle));\n    float c = getValueFromCosTable(abs(angle));\n    float s = (abs(angle) < PI/2.0)?\n        -getValueFromCosTable(abs(angle) + PI/2.0):\n        getValueFromCosTable(abs(angle) - PI/2.0);\n    return complex(c, sign(angle)*s);\n}\n\ncomplex mul(complex z, complex w) {\n    return complex(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\ncomplex2 c2C1(complex2 z, complex w) {\n    return complex2(mul(z.rg, w), mul(z.ba, w));\n}\n\ncomplex2 getOdd1(float x, float y) {\n    return (!isVertical)? texture2D(tex, vec2(x + blockSize/2.0, y)):\n                          texture2D(tex, vec2(x, y + blockSize/2.0));\n}\n\ncomplex2 getEven2(float x, float y) {\n    return (!isVertical)? texture2D(tex, vec2(x - blockSize/2.0, y)):\n                          texture2D(tex, vec2(x, y - blockSize/2.0));\n}\n\nvoid main() {\n    float val = (!isVertical)? mod(UV[0], blockSize): mod(UV[1], blockSize);\n    // even lower half\n    complex2 even1 = texture2D(tex, UV);\n    complex2 odd1 = getOdd1(UV[0], UV[1]);\n    float angle1 = angleSign*2.0*PI*(val - 0.5/size)/blockSize;\n    complex2 out1 = scale*(even1 + c2C1(odd1, expI(angle1)));\n    // odd upper half\n    complex2 even2 = getEven2(UV[0], UV[1]);\n    complex2 odd2 = texture2D(tex, UV);\n    float angle2 = angleSign*2.0*PI\n        *((val - 0.5/size) - blockSize/2.0)/blockSize;\n    complex2 out2 = scale*(even2 - c2C1(odd2, expI(angle2)));\n    fragColor = (val <= blockSize/2.0)? out1: out2;\n}\n`;
shaders[`./shaders/fftshift.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n// uniform bool isVertical;\n\n\nvoid main() {\n    float u0 = UV[0], v0 = UV[1];\n    float u = (u0 < 0.5)? u0 + 0.5: u0 - 0.5;\n    float v = (v0 < 0.5)? v0 + 0.5: v0 - 0.5;\n    fragColor = texture2D(tex, vec2(u, v));\n}`;
shaders[`./shaders/gray-scale.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\n\nvoid main() {\n    vec3 color = vec3(texture2D(tex, UV)[0] + offset);\n    fragColor = vec4(min(brightness*color, maxBrightness), 1.0);\n}\n\n`;
shaders[`./shaders/rev-bit-sort2.frag`] = `/* Reverse bit sort a texture whose width and height must be a power\nof two.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform int width;\nuniform int height;\n\nbool revBitSort2SingleIter(inout int rev, inout int i,\n                           inout int asc, inout int des, int stop) {\n    if (i/des > 0) {\n        rev += asc;\n	i -= des;\n    }\n    des /= 2, asc *= 2;\n    if (asc == 2*stop)\n        return false;\n    return true;\n}\n\n/* Older versions of GLSL do not support for loops.\n This very long function reverse bit sorts a finite-sized\n input texture with power of two dimensions without using any for loops.\n For more more modern versions of GLSL a different implementation of reverse\n bit sorting which uses for loops is used instead.\n*/\nvec2 revBitSort2NoForLoop(vec2 uv) {\n    vec2 uv2 = vec2(0.0, 0.0);\n    int indexU = int(floor(uv[0]*float(width)));\n    int indexV = int(floor(uv[1]*float(height)));\n \n    int rev = 0, i = indexU;\n    int asc = 1, des = width/2;\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n    if (!revBitSort2SingleIter(rev, i, asc, des, width/2))\n        uv2[0] = (float(rev) + 0.5)/float(width);\n\n    rev = 0, i = indexV;\n    asc = 1, des = height/2;\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n    if (!revBitSort2SingleIter(rev, i, asc, des, height/2))\n        uv2[1] = (float(rev) + 0.5)/float(height);\n\n    return uv2;\n}\n\nvec2 revBitSort2(vec2 uv) {\n    #if (!defined(GL_ES) && __VERSION__ >= 120) || (defined(GL_ES) && __VERSION__ > 300)\n    vec2 uv2 = vec2(0.0, 0.0);\n    int indexU = int(floor(uv[0]*float(width)));\n    int indexV = int(floor(uv[1]*float(height)));\n    int rev = 0, i = indexU;\n    for (int asc = 1, des = width/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uv2[0] = (float(rev) + 0.5)/float(width);\n    rev = 0, i = indexV;\n    for (int asc = 1, des = height/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uv2[1] = (float(rev) + 0.5)/float(height);\n    return uv2;\n    #else\n    return revBitSort2NoForLoop(uv);\n    #endif\n}\n\nvoid main() {\n     fragColor = texture2D(tex, revBitSort2(UV));\n}\n`;
shaders[`./shaders/scale.frag`] = `/* Scale a texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float scale;\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = scale*texture2D(tex, UV);\n}\n`;
shaders[`./shaders/sketch-potential.frag`] = `/* Shader for sketching a potential */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform vec2 location;\nuniform float amplitude;\nuniform vec2 sigmaXY;\n\nvoid main() {\n    complex oldVal = texture2D(tex, UV).xy;\n    float x0 = location.x;\n    float y0 = location.y;\n    float sigmaX = sigmaXY[0];\n    float sigmaY = sigmaXY[1];\n    float x = UV.x;\n    float y = UV.y;\n    float gx = exp(-0.5*(x - x0)*(x - x0)/(sigmaX*sigmaX));\n    float gy = exp(-0.5*(y - y0)*(y - y0)/(sigmaY*sigmaY));\n    complex newVal = oldVal + amplitude*complex(gx*gy, 0.0);\n    if (newVal.x > 2.0)\n        newVal.x = (oldVal.x < 2.0)? 2.0: oldVal.x;\n    if (newVal.x < 0.0)\n        newVal.x = (oldVal.x > 0.0)? 0.0: oldVal.x; \n    fragColor = vec4(newVal, newVal);\n\n}\n`;
shaders[`./shaders/split-step-kinetic.frag`] = `/* GLSL implementation of the momentum step for the split operator algorithm\n\nReferences:\n\nSplit-Operator Method:\nJames Schloss. The Split Operator Method - Arcane Algorithm Archive.\nhttps://www.algorithm-archive.org/contents/split-operator_method/\n split-operator_method.html\n*/\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform int numberOfDimensions;\nuniform ivec2 texelDimensions2D;\nuniform vec2 dimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\n\n#define complex vec2\n#define complex2 vec4\n\nconst float PI = 3.141592653589793;\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\nuniform complex dt;\nuniform float m;\nuniform float hbar;\nuniform sampler2D psiTex;\nuniform bool useCustomKETex;\nuniform sampler2D customKETex;\n\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\ncomplex mul(complex z, float r) {\n    return r*z;\n}\n\ncomplex mul(float r, complex z) {\n    return mul(z, r);\n}\n\ncomplex mul(complex z1, complex z2) {\n    return complex(z1.x*z2.x - z1.y*z2.y, \n                   z1.x*z2.y + z1.y*z2.x);\n}\n\ncomplex expC(complex z) {\n    return complex(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));\n}\n\nvec3 getMomentum() {\n    float u, v, w;\n    float width, height, length_;\n    int texelWidth, texelHeight, texelLength;\n    if (numberOfDimensions == 3) {\n        width = dimensions3D[0];\n        height = dimensions3D[1];\n        length_ = dimensions3D[2];\n        texelWidth = texelDimensions3D[0];\n        texelHeight = texelDimensions3D[1];\n        texelLength = texelDimensions3D[2];\n        vec3 uvw = to3DTextureCoordinates(UV);\n        u = uvw[0], v = uvw[1], w = uvw[2];\n    } else {\n        width = dimensions2D[0];\n        height = dimensions2D[1];\n        length_ = 0.0;\n        texelWidth = texelDimensions2D[0];\n        texelHeight = texelDimensions2D[1];\n        texelLength = 0;\n        u = UV[0], v = UV[1], w = 0.0;\n    }\n    float freqU = ((u < 0.5)? u: -1.0 + u)*float(texelWidth) - 0.5;\n    float freqV = ((v < 0.5)? v: -1.0 + v)*float(texelHeight) - 0.5;\n    float freqW = ((w < 0.5)? w: -1.0 + w)*float(texelLength) - 0.5;\n    return vec3(2.0*PI*freqU/width, 2.0*PI*freqV/height, \n                (numberOfDimensions == 3)? 2.0*PI*freqW/length_: 0.0);\n}\n\nvoid main() {\n    complex2 psi = texture2D(psiTex, UV);\n    complex psi1 = psi.xy;\n    complex psi2 = psi.zw;\n    complex idt = mul(IMAG_UNIT, dt);\n    if (useCustomKETex) {\n        complex kineticEnergy = texture2D(customKETex, UV).xy;\n        fragColor = vec4(mul(expC(-mul(idt, kineticEnergy)/hbar), psi1),\n                         mul(expC(-mul(idt, kineticEnergy)/hbar), psi2));\n    } else {\n        vec3 p = getMomentum();\n        float p2 = p.x*p.x + p.y*p.y + p.z*p.z;\n        fragColor = vec4(mul(expC(-idt*p2/(2.0*m*hbar)), psi1),\n                         mul(expC(-idt*p2/(2.0*m*hbar)), psi2));\n    }\n\n}`;
shaders[`./shaders/split-step-spatial.frag`] = `/* GLSL implementation of the spatial step \n(that exponential term which only depends on position)\n for the split operator algorithm\n\nReferences:\n\nSplit-Operator Method:\nJames Schloss. The Split Operator Method - Arcane Algorithm Archive.\nhttps://www.algorithm-archive.org/contents/split-operator_method/\n split-operator_method.html\n \n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define complex2 vec4\n\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\nuniform complex dt;\nuniform float m;\nuniform float hbar;\nuniform sampler2D potentialTex;\nuniform sampler2D psiTex;\n\n\ncomplex mul(complex z1, complex z2) {\n    return complex(z1.x*z2.x - z1.y*z2.y, \n                   z1.x*z2.y + z1.y*z2.x);\n}\n\ncomplex expC(complex z) {\n    return complex(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));\n}\n\n\nvoid main() {\n    complex2 psi = texture2D(psiTex, UV);\n    complex psi1 = psi.xy;\n    complex psi2 = psi.zw;\n    complex potential = texture2D(potentialTex, UV).xy;\n    complex iVdt = mul(IMAG_UNIT, mul(potential, dt));\n    fragColor = vec4(mul(expC(-iVdt/hbar), psi1),\n                     mul(expC(-iVdt/hbar), psi2));\n}\n`;
shaders[`./shaders/surface-domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\nvarying vec3 NORMAL;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nin vec3 NORMAL;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    float ambient = 0.01;\n    // float diffuse = abs(dot(NORMAL, vec3(0.0, 0.0, -1.0)));\n    float brightness2 = brightness*length(z2);\n    vec3 color = ambient \n        + (\n            1.0 // + diffuse\n        )*brightness2*argumentToColor(atan(z2.y, z2.x));\n    fragColor = vec4(color, 1.0);\n}\n`;
shaders[`./shaders/surface-single-color.frag`] = `/* Output a single colour for every texel of the output texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\nvarying vec3 NORMAL;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nin vec3 NORMAL;\nout vec4 fragColor;\n#endif\n\nuniform vec4 color;\n\nvoid main() {\n    // float brightness = dot(NORMAL, vec3(0.0, 0.0, -1.0));\n    float diffuse = 0.5*abs(dot(NORMAL, vec3(0.0, 0.0, 1.0)));\n    fragColor = vec4(color.rgb*(diffuse + 0.25), color.a);\n}\n`;
shaders[`./shaders/surface-vert.vert`] = ` \n#if __VERSION__ <= 120\nattribute vec2 position;\nvarying vec2 UV;\nvarying vec3 NORMAL;\n#else\nin vec2 position;\nout vec2 UV;\nout vec3 NORMAL;\n#endif\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n\n#define quaternion vec4\n\nuniform sampler2D heightTex;\nuniform quaternion rotation;\nuniform vec3 translate;\nuniform float heightScale;\nuniform float scale;\nuniform ivec2 dimensions2D;\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion q) {\n    return quaternion(-q.x, -q.y, -q.z, q.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    return quaternion(mul(conj(r), mul(x, r)).xyz, 1.0);\n}\n\nvec4 project(vec4 x) {\n    vec4 y;\n    y[0] = x[0]*5.0/(x[2] + 5.0);\n    y[1] = x[1]*5.0/(x[2] + 5.0);\n    y[2] = x[2]/5.0;\n    y[3] = 1.0;\n    return y;\n}\n\nvec3 getNormal(vec2 xy) {\n    float x = xy[0], y = xy[1];\n    float dx = 1.0/float(dimensions2D[0]);\n    float dy = 1.0/float(dimensions2D[1]);\n    float height = texture2D(heightTex, xy)[0];\n    float heightR = texture2D(heightTex, xy + vec2(dx, 0.0))[0];\n    float heightU = texture2D(heightTex, xy + vec2(0.0, dy))[0];\n    vec3 vC = vec3(x, y, -height);\n    vec3 vR = vec3(x + dx, y, -heightR);\n    vec3 vU = vec3(x, y + dy, -heightU);\n    vec3 eU = vU - vC;\n    vec3 eR = vR - vC;\n    return normalize(mul(quaternion(eR, 0.0), quaternion(eU, 0.0)).xyz);\n}\n\n\nvoid main() {\n    UV = position;\n    float height = texture2D(heightTex, UV).r;\n    vec4 tPosition = scale*(vec4(position, 0.0, 0.0) \n                            - vec4(0.5, 0.5,\n                                   heightScale*height, \n                                   // min(heightScale*height, 0.5), \n                                   0.0));\n    NORMAL = rotate(quaternion(getNormal(UV), 1.0), conj(rotation)).xyz;\n    gl_Position = project(rotate(tPosition, rotation)\n                          + vec4(translate, 0.0));\n}`;
shaders[`./shaders/wavepacket.frag`] = `/* Generate a new wavepacket. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\ncomplex mul(complex a, complex b) {\n    return complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// wave number of the wave packet (w.r.t. simulation domains)\nuniform vec2 waveNumber;\n// Position Offset of the wave packet in texture coordinates\nuniform vec2 texOffset;\n// Amplitude of the wave packet\nuniform float amplitude;\n// Standard deviation of the wave packet, in texture coordinates\nuniform vec2 sigmaXY;\n\nvoid main() {\n    float x = UV.x;\n    float y = UV.y;\n    float x0 = texOffset.x;\n    float y0 = texOffset.y;\n    float sx = sigmaXY.x;\n    float sy = sigmaXY.y;\n    float gx = exp(-0.25*pow((x - x0)/sx, 2.0))/sqrt(sx*sqrt(2.0*PI));\n    float gy = exp(-0.25*pow((y - y0)/sy, 2.0))/sqrt(sy*sqrt(2.0*PI));\n    float g = gx*gy;\n    float nx = waveNumber.x;\n    float ny = waveNumber.y;\n    complex phase = complex(cos(2.0*PI*(nx*x + ny*y)),\n                            sin(2.0*PI*(nx*x + ny*y)));\n    fragColor = amplitude*g*vec4(phase, phase);\n}\n`;
const SHADERS = shaders;
export default SHADERS;
export const getShader = name => {console.log(`Getting ${name}.`); return SHADERS[name];}
