let shaders = {};
shaders[`./shaders/fft/fft-iter-cube.frag`] = `/* This shader is used to implement the iterative part of the \nCooley-Tukey iterative radix-2 FFT algorithm applied to a 3D array of \ndata stored as a 2D texture. \nIt is assumed that each side length of this 3D array are equal.\n\nReferences:\n\nWikipedia - Cooley–Tukey FFT algorithm\nhttps://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\nMathWorld Wolfram - Fast Fourier Transform:\nhttp://mathworld.wolfram.com/FastFourierTransform.html\n\nWilliam Press et al.\n12.2 Fast Fourier Transform (FFT) - in Numerical Recipes\nhttps://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n\nuniform sampler2D tex;\nuniform float blockSize;\nuniform float angleSign;\nuniform float size;\nuniform float scale;\n\nuniform bool useCosTable;\nuniform sampler2D cosTableTex;\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\n\n#define complex vec2\n#define complex2 vec4\n\nconst float PI = 3.141592653589793;\n\n\nfloat getValueFromCosTable(float angle) {\n    return texture2D(cosTableTex,\n                     vec2(angle/PI + 0.5/(size/2.0), 0.5)).r;\n}\n\ncomplex expI(float angle) {\n    if (!useCosTable)\n        return complex(cos(angle), sin(angle));\n    float c = getValueFromCosTable(abs(angle));\n    float s = (abs(angle) < PI/2.0)?\n        -getValueFromCosTable(abs(angle) + PI/2.0):\n        getValueFromCosTable(abs(angle) - PI/2.0);\n    return complex(c, sign(angle)*s);\n}\n\ncomplex mul(complex z, complex w) {\n    return complex(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\ncomplex2 c2C1(complex2 z, complex w) {\n    return complex2(mul(z.rg, w), mul(z.ba, w));\n}\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    vec3 uvw = to3DTextureCoordinates(UV);\n    vec3 blockPosition = vec3(\n        mod(uvw[0], blockSize),\n        mod(uvw[1], blockSize),\n        mod(uvw[2], blockSize));\n    float h = blockSize/2.0;\n    vec3 signFactor = vec3((blockPosition.x <= h)? 1.0: -1.0,\n                           (blockPosition.y <= h)? 1.0: -1.0,\n                           (blockPosition.z <= h)? 1.0: -1.0);\n    vec3 offset = vec3((blockPosition.x <= h)? 0.0: -1.0,\n                       (blockPosition.y <= h)? 0.0: -1.0,\n                       (blockPosition.z <= h)? 0.0: -1.0);\n    complex2 eee = texture2D(\n        tex, to2DTextureCoordinates(uvw + h*offset));\n    complex2 oee = texture2D(\n        tex, to2DTextureCoordinates(uvw + h*(vec3(1.0, 0.0, 0.0) + offset)));\n    complex2 eoe = texture2D(\n        tex, to2DTextureCoordinates(uvw + h*(vec3(0.0, 1.0, 0.0) + offset)));\n    complex2 ooe = texture2D(\n        tex, to2DTextureCoordinates(uvw + h*(vec3(1.0, 1.0, 0.0) + offset)));\n    complex2 eeo = texture2D(\n        tex, to2DTextureCoordinates(uvw + h*(vec3(0.0, 0.0, 1.0) + offset)));\n    complex2 oeo = texture2D(\n        tex, to2DTextureCoordinates(uvw + h*(vec3(1.0, 0.0, 1.0) + offset)));\n    complex2 eoo = texture2D(\n        tex, to2DTextureCoordinates(uvw + h*(vec3(0.0, 1.0, 1.0) + offset)));\n    complex2 ooo = texture2D(\n        tex, to2DTextureCoordinates(uvw + h*(vec3(1.0, 1.0, 1.0) + offset)));\n    vec3 angle = angleSign*2.0*PI*(\n        blockPosition - vec3(0.5/size) + h*offset)/blockSize;\n    complex eIAngleX = expI(angle.x);\n    complex eIAngleY = expI(angle.y);\n    complex eIAngleZ = expI(angle.z);\n    fragColor = scale*scale*scale*(\n        eee\n         + signFactor.x*c2C1(oee, eIAngleX)\n         + signFactor.y*c2C1(eoe, eIAngleY)\n         + signFactor.z*c2C1(eeo, eIAngleZ)\n         + signFactor.x*signFactor.y*c2C1(ooe, mul(eIAngleX, eIAngleY))\n         + signFactor.z*signFactor.x*c2C1(oeo, mul(eIAngleZ, eIAngleX))\n         + signFactor.y*signFactor.z*c2C1(eoo, mul(eIAngleY, eIAngleZ))\n         + signFactor.x*signFactor.y*signFactor.z\n            *c2C1(ooo, mul(mul(eIAngleX, eIAngleY), eIAngleZ))\n    );\n}`;
shaders[`./shaders/fft/fft-iter-square.frag`] = `/* This shader is used to implement the iterative part of the\nCooley-Tukey iterative radix-2 FFT algorithm. It is assumed that \nthe width of the input texture is equal to its height.\n\nReferences:\n\nWikipedia - Cooley–Tukey FFT algorithm\nhttps://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\nMathWorld Wolfram - Fast Fourier Transform:\nhttp://mathworld.wolfram.com/FastFourierTransform.html\n\nWilliam Press et al.\n12.2 Fast Fourier Transform (FFT) - in Numerical Recipes\nhttps://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf\n\n*/\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define complex2 vec4\n\nuniform sampler2D tex;\nuniform float blockSize;\nuniform float angleSign;\nuniform float size;\nuniform float scale;\n\nuniform bool useCosTable;\nuniform sampler2D cosTableTex;\n\nconst float PI = 3.141592653589793;\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\n\nfloat getValueFromCosTable(float angle) {\n    return texture2D(cosTableTex,\n                     vec2(angle/PI + 0.5/(size/2.0), 0.5)).r;\n}\n\ncomplex expI(float angle) {\n    if (!useCosTable)\n        return complex(cos(angle), sin(angle));\n    float c = getValueFromCosTable(abs(angle));\n    float s = (abs(angle) < PI/2.0)?\n        -getValueFromCosTable(abs(angle) + PI/2.0):\n        getValueFromCosTable(abs(angle) - PI/2.0);\n    return complex(c, sign(angle)*s);\n}\n\ncomplex mul(complex z, complex w) {\n    return complex(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\ncomplex2 c2C1(complex2 z, complex w) {\n    return complex2(mul(z.rg, w), mul(z.ba, w));\n}\n\nvoid main() {\n    vec2 blockPosition = vec2(mod(UV[0], blockSize), mod(UV[1], blockSize));\n    float h = blockSize/2.0;\n    vec2 signFactor = vec2((blockPosition.x <= h)? 1.0: -1.0,\n                           (blockPosition.y <= h)? 1.0: -1.0);\n    vec2 offset = vec2((blockPosition.x <= h)? 0.0: -1.0,\n                       (blockPosition.y <= h)? 0.0: -1.0);\n    complex2 ee = texture2D(tex, UV + h*offset);\n    complex2 oe = texture2D(tex, UV + h*(vec2(1.0, 0.0) + offset));\n    complex2 eo = texture2D(tex, UV + h*(vec2(0.0, 1.0) + offset));\n    complex2 oo = texture2D(tex, UV + h*(vec2(1.0, 1.0) + offset));\n    vec2 angle = angleSign*2.0*PI*(\n        blockPosition - vec2(0.5/size) + h*offset)/blockSize;\n    complex eIAngleX = expI(angle.x);\n    complex eIAngleY = expI(angle.y);\n    fragColor = scale*scale*(ee \n         + signFactor.x*c2C1(oe, eIAngleX) + signFactor.y*c2C1(eo, eIAngleY)\n         + signFactor.x*signFactor.y*c2C1(oo, mul(eIAngleX, eIAngleY)));\n}\n`;
shaders[`./shaders/fft/fft-iter.frag`] = `/* This shader is used to implement part of the \nCooley-Tukey iterative radix-2 FFT algorithm.\n\nReferences:\n\nWikipedia - Cooley–Tukey FFT algorithm\nhttps://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\nMathWorld Wolfram - Fast Fourier Transform:\nhttp://mathworld.wolfram.com/FastFourierTransform.html\n\nWilliam Press et al.\n12.2 Fast Fourier Transform (FFT) - in Numerical Recipes\nhttps://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf\n\n*/\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define complex2 vec4\n\nuniform sampler2D tex;\nuniform float blockSize;\nuniform bool isVertical;\nuniform float angleSign;\nuniform float size;\nuniform float scale;\n\nuniform bool useCosTable;\nuniform sampler2D cosTableTex;\n\nconst float PI = 3.141592653589793;\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\n\nfloat getValueFromCosTable(float angle) {\n    return texture2D(cosTableTex,\n                     vec2(angle/PI + 0.5/(size/2.0), 0.5)).r;\n}\n\ncomplex expI(float angle) {\n    if (!useCosTable)\n        return complex(cos(angle), sin(angle));\n    float c = getValueFromCosTable(abs(angle));\n    float s = (abs(angle) < PI/2.0)?\n        -getValueFromCosTable(abs(angle) + PI/2.0):\n        getValueFromCosTable(abs(angle) - PI/2.0);\n    return complex(c, sign(angle)*s);\n}\n\ncomplex mul(complex z, complex w) {\n    return complex(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\ncomplex2 c2C1(complex2 z, complex w) {\n    return complex2(mul(z.rg, w), mul(z.ba, w));\n}\n\ncomplex2 getOdd1(float x, float y) {\n    return (!isVertical)? texture2D(tex, vec2(x + blockSize/2.0, y)):\n                          texture2D(tex, vec2(x, y + blockSize/2.0));\n}\n\ncomplex2 getEven2(float x, float y) {\n    return (!isVertical)? texture2D(tex, vec2(x - blockSize/2.0, y)):\n                          texture2D(tex, vec2(x, y - blockSize/2.0));\n}\n\nvoid main() {\n    float val = (!isVertical)? mod(UV[0], blockSize): mod(UV[1], blockSize);\n    // even lower half\n    complex2 even1 = texture2D(tex, UV);\n    complex2 odd1 = getOdd1(UV[0], UV[1]);\n    float angle1 = angleSign*2.0*PI*(val - 0.5/size)/blockSize;\n    complex2 out1 = scale*(even1 + c2C1(odd1, expI(angle1)));\n    // odd upper half\n    complex2 even2 = getEven2(UV[0], UV[1]);\n    complex2 odd2 = texture2D(tex, UV);\n    float angle2 = angleSign*2.0*PI\n        *((val - 0.5/size) - blockSize/2.0)/blockSize;\n    complex2 out2 = scale*(even2 - c2C1(odd2, expI(angle2)));\n    fragColor = (val <= blockSize/2.0)? out1: out2;\n}\n`;
shaders[`./shaders/fft/fft-iter3d.frag`] = `/* This shader is used to implement part of the \nCooley-Tukey iterative radix-2 FFT algorithm for 3D data stored\nin 2D textures.\n\nReferences:\n\nWikipedia - Cooley–Tukey FFT algorithm\nhttps://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\nMathWorld Wolfram - Fast Fourier Transform:\nhttp://mathworld.wolfram.com/FastFourierTransform.html\n\nWilliam Press et al.\n12.2 Fast Fourier Transform (FFT) - in Numerical Recipes\nhttps://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n\nuniform sampler2D tex;\nuniform float blockSize;\nuniform int orientation;\nuniform float angleSign;\nuniform float size;\nuniform float scale;\n\nuniform bool useCosTable;\nuniform sampler2D cosTableTex;\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\n\n#define complex vec2\n#define complex2 vec4\n\nconst float PI = 3.141592653589793;\n\nconst int ORIENTATION_0 = 0;\nconst int ORIENTATION_1 = 1;\nconst int ORIENTATION_2 = 2;\n\n\nfloat getValueFromCosTable(float angle) {\n    return texture2D(cosTableTex,\n                     vec2(angle/PI + 0.5/(size/2.0), 0.5)).r;\n}\n\ncomplex expI(float angle) {\n    if (!useCosTable)\n        return complex(cos(angle), sin(angle));\n    float c = getValueFromCosTable(abs(angle));\n    float s = (abs(angle) < PI/2.0)?\n        -getValueFromCosTable(abs(angle) + PI/2.0):\n        getValueFromCosTable(abs(angle) - PI/2.0);\n    return complex(c, sign(angle)*s);\n}\n\ncomplex mul(complex z, complex w) {\n    return complex(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\ncomplex2 c2C1(complex2 z, complex w) {\n    return complex2(mul(z.rg, w), mul(z.ba, w));\n}\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvec4 getOdd1(vec3 uvw) {\n    if (orientation == ORIENTATION_0) {\n        vec3 uvw2 = vec3(uvw[0] + 0.5*blockSize, uvw[1], uvw[2]);\n        return texture2D(tex, to2DTextureCoordinates(uvw2));\n    } else if (orientation == ORIENTATION_1) {\n        vec3 uvw2 = vec3(uvw[0], uvw[1] + 0.5*blockSize, uvw[2]);\n        return texture2D(tex, to2DTextureCoordinates(uvw2));\n    } else if (orientation == ORIENTATION_2) {\n        vec3 uvw2 = vec3(uvw[0], uvw[1], uvw[2] + 0.5*blockSize);\n        return texture2D(tex, to2DTextureCoordinates(uvw2));\n    }\n}\n\nvec4 getEven2(vec3 uvw) {\n    if (orientation == ORIENTATION_0) {\n        vec3 uvw2 = vec3(uvw[0] - 0.5*blockSize, uvw[1], uvw[2]);\n        return texture2D(tex, to2DTextureCoordinates(uvw2));\n    } else if (orientation == ORIENTATION_1) {\n        vec3 uvw2 = vec3(uvw[0], uvw[1] - 0.5*blockSize, uvw[2]);\n        return texture2D(tex, to2DTextureCoordinates(uvw2));\n    } else if (orientation == ORIENTATION_2) {\n        vec3 uvw2 = vec3(uvw[0], uvw[1], uvw[2] - 0.5*blockSize);\n        return texture2D(tex, to2DTextureCoordinates(uvw2));\n    }\n}\n\nvoid main() {\n    vec3 uvw = to3DTextureCoordinates(UV);\n    float val = 0.0;\n    if (orientation == ORIENTATION_0) {\n        val = mod(uvw[0], blockSize);\n    } else if (orientation == ORIENTATION_1) {\n        val = mod(uvw[1], blockSize);\n    } else if (orientation == ORIENTATION_2) {\n        val = mod(uvw[2], blockSize);\n    }\n    vec4 texVal = texture2D(tex, UV);\n\n    // Even lower half\n    vec4 even1 = texVal;\n    vec4 odd1 = getOdd1(uvw);\n    float angle1 = angleSign*2.0*PI*(val - 0.5/size)/blockSize;\n    complex2 out1 = scale*(even1 + c2C1(odd1, expI(angle1)));\n\n    // Odd upper half\n    complex2 even2 = getEven2(uvw);\n    complex2 odd2 = texVal;\n    float angle2 = angleSign*2.0*PI\n        *((val - 0.5/size) - blockSize/2.0)/blockSize;\n    complex2 out2 = scale*(even2 - c2C1(odd2, expI(angle2)));\n\n    fragColor = (val <= blockSize/2.0)? out1: out2;\n}\n`;
shaders[`./shaders/fft/fftshift.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\n\nvoid main() {\n    float u0 = UV[0], v0 = UV[1];\n    float u = (u0 < 0.5)? u0 + 0.5: u0 - 0.5;\n    float v = (v0 < 0.5)? v0 + 0.5: v0 - 0.5;\n    fragColor = texture2D(tex, vec2(u, v));\n}`;
shaders[`./shaders/fft/fftshift3d.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n\nuniform sampler2D tex;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\nuniform int orientation;\n\nconst int ORIENTATION_0 = 0;\nconst int ORIENTATION_1 = 1;\nconst int ORIENTATION_2 = 2;\n\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    vec3 uvw0 = to3DTextureCoordinates(UV);\n    float u0 = uvw0[0], v0 = uvw0[1], w0 = uvw0[2];\n    float u = (u0 < 0.5)? u0 + 0.5: u0 - 0.5;\n    float v = (v0 < 0.5)? v0 + 0.5: v0 - 0.5;\n    float w = (w0 < 0.5)? w0 + 0.5: w0 - 0.5;\n    vec3 uvw = vec3(u, v, w);\n    fragColor = texture2D(tex, to2DTextureCoordinates(uvw));\n}\n`;
shaders[`./shaders/fft/rev-bit-sort2-3d.frag`] = `/* Reverse bit sort a 3D array of data that's organized into \na single 2D texture. It is assumed the the side lengths of this\n3D array are a power of two in size.\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nbool revBitSort2SingleIter(inout int rev, inout int i,\n                           inout int asc, inout int des, int stop) {\n    if (i/des > 0) {\n        rev += asc;\n	i -= des;\n    }\n    des /= 2, asc *= 2;\n    if (asc == 2*stop)\n        return false;\n    return true;\n}\n\n/* Older versions of GLSL do not support for loops.\n This very long function is used to reverse bit sort a finite-sized\n input texture with power of two dimensions without using any for loops.\n For more modern versions of GLSL a different implementation of reverse\n bit sorting which includes for loops is used instead.\n*/\nfloat revBitSort2SingleDimension(int index, int size) {\n    int rev = 0, i = index;\n    int asc = 1, des = size/2;\n    float retVal;\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    return retVal;\n}\n\nvec3 revBitSort2NoForLoop(vec3 uvw) {\n    int indexU = int(floor(uvw[0]*float(texelDimensions3D[0])));\n    int indexV = int(floor(uvw[1]*float(texelDimensions3D[1])));\n    int indexW = int(floor(uvw[2]*float(texelDimensions3D[2])));\n    return vec3(\n        revBitSort2SingleDimension(indexU, texelDimensions3D[0]),\n        revBitSort2SingleDimension(indexV, texelDimensions3D[1]),\n        revBitSort2SingleDimension(indexW, texelDimensions3D[2])\n    );\n}\n\nvec3 revBitSort2(vec3 uvw) {\n    #if (!defined(GL_ES) && __VERSION__ >= 120) || (defined(GL_ES) && __VERSION__ > 300)\n    vec3 uvw2 = vec3(0.0, 0.0, 0.0);\n    int indexU = int(floor(uvw[0]*float(texelDimensions3D[0])));\n    int indexV = int(floor(uvw[1]*float(texelDimensions3D[1])));\n    int indexW = int(floor(uvw[2]*float(texelDimensions3D[2])));\n    // u\n    int rev = int(0), i = indexU;\n    for (int asc = 1,\n         des = texelDimensions3D[0]/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uvw2[0] = (float(rev) + 0.5)/float(texelDimensions3D[0]);\n    // v\n    rev = 0, i = indexV;\n    for (int asc = 1,\n         des = texelDimensions3D[1]/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uvw2[1] = (float(rev) + 0.5)/float(texelDimensions3D[1]);\n    // w\n    rev = 0, i = indexW;\n    for (int asc = 1,\n         des = texelDimensions3D[2]/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uvw2[2] = (float(rev) + 0.5)/float(texelDimensions3D[2]);\n    return uvw2;\n    #else\n    return revBitSort2NoForLoop(uvw);\n    #endif\n}\n\n\nvoid main() {\n    vec3 uvw = to3DTextureCoordinates(UV);\n    fragColor = texture2D(tex, to2DTextureCoordinates(revBitSort2(uvw)));\n}`;
shaders[`./shaders/fft/rev-bit-sort2.frag`] = `/* Reverse bit sort a texture whose width and height must be a power\nof two.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform int width;\nuniform int height;\n\nbool revBitSort2SingleIter(inout int rev, inout int i,\n                           inout int asc, inout int des, int stop) {\n    if (i/des > 0) {\n        rev += asc;\n	i -= des;\n    }\n    des /= 2, asc *= 2;\n    if (asc == 2*stop)\n        return false;\n    return true;\n}\n\n/* Older versions of GLSL do not support for loops.\n This very long function is used to reverse bit sort a finite-sized\n input texture with power of two dimensions without using any for loops.\n For more modern versions of GLSL a different implementation of reverse\n bit sorting which includes for loops is used instead.\n*/\nfloat revBitSort2SingleDimension(int index, int size) {\n    int rev = 0, i = index;\n    int asc = 1, des = size/2;\n    float retVal;\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    if (!revBitSort2SingleIter(rev, i, asc, des, size/2))\n        retVal = (float(rev) + 0.5)/float(size);\n    return retVal;\n}\n\nvec2 revBitSort2NoForLoop(vec2 uv) {\n    int indexU = int(floor(uv[0]*float(width)));\n    int indexV = int(floor(uv[1]*float(height)));\n    return vec2(\n        revBitSort2SingleDimension(indexU, width),\n        revBitSort2SingleDimension(indexV, height)\n    );\n}\n\nvec2 revBitSort2(vec2 uv) {\n    #if (!defined(GL_ES) && __VERSION__ >= 120) || (defined(GL_ES) && __VERSION__ > 300)\n    vec2 uv2 = vec2(0.0, 0.0);\n    int indexU = int(floor(uv[0]*float(width)));\n    int indexV = int(floor(uv[1]*float(height)));\n    int rev = 0, i = indexU;\n    for (int asc = 1, des = width/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uv2[0] = (float(rev) + 0.5)/float(width);\n    rev = 0, i = indexV;\n    for (int asc = 1, des = height/2; des > 0; des /= 2, asc *= 2) {\n        if (i/des > 0) {\n            rev += asc;\n            i -= des;\n        }\n    }\n    uv2[1] = (float(rev) + 0.5)/float(height);\n    return uv2;\n    #else\n    return revBitSort2NoForLoop(uv);\n    #endif\n}\n\nvoid main() {\n     fragColor = texture2D(tex, revBitSort2(UV));\n}\n`;
shaders[`./shaders/gradient/gradient3d.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nuniform int orderOfAccuracy;\n\n#define USE_TEXTURE_WRAPPING 0\n#define DIRICHLET 1\n#define DIRICHLET_MASK 2\nuniform int boundaryType;\n\nuniform sampler2D boundaryMaskTex;\n\nuniform int staggeredMode;\n\nuniform int index;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\nuniform vec3 dr; // Spartial step sizes\nuniform vec3 dimensions3D; // Dimensions of simulation\n\n#define X_ORIENTATION 0\n#define Y_ORIENTATION 1\n#define Z_ORIENTATION 2\n\n/* Table of finite difference stencils:\n\n - Fornberg, B. (1988).\n Generation of Finite Difference Formulas on Arbitrarily Spaced Grids.\n Mathematics of Computation, 51(184), 699-706.\n https://doi.org/10.1090/S0025-5718-1988-0935077-0\n\n*/\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n/* Get the boundary value, given the 2D texture coordinate\nuv and its 3D equivalent counterpart uvw. */\nvec4 boundaryValue(vec2 uv, vec3 uvw) {\n    if (boundaryType == USE_TEXTURE_WRAPPING)\n        return vec4(1.0);\n    else if (boundaryType == DIRICHLET)\n        return  (\n            uvw[0] < dr[0]/dimensions3D[0] ||\n            uvw[1] < dr[1]/dimensions3D[1] ||\n            uvw[2] < dr[2]/dimensions3D[2] ||\n            uvw[0] > (1.0 - dr[0]/dimensions3D[0]) ||\n            uvw[1] > (1.0 - dr[1]/dimensions3D[1]) ||\n            uvw[2] > (1.0 - dr[2]/dimensions3D[2]))? vec4(0.0): vec4(1.0);\n    else if (boundaryType == DIRICHLET_MASK)\n        return texture2D(boundaryMaskTex, uv);\n}\n\n/* Sample the texture at an integer number of texel units (i, j, and k)\naway from the input 3D coordinate variable centre. */\nvec3 offsetTexelCoordinate3D(vec3 centre, int i, int j, int k) {\n    return centre + vec3(float(i)*dr[0]/dimensions3D[0],\n                         float(j)*dr[1]/dimensions3D[1],\n                         float(k)*dr[2]/dimensions3D[2]);\n}\n\n/* Sample the texture tex with its boundary value at an integer number of\ntexel units away from that position given in the varying/in UV variable. \nThe integer i denotes the  offset along the 0th direction, \nj along the 1st, and k along the 2nd. */\nvec4 valueAt(sampler2D tex, int i, int j, int k) {\n    vec3 uvw = to3DTextureCoordinates(UV).xyz;\n    vec3 uvwOffset = offsetTexelCoordinate3D(uvw, i, j, k);\n    vec2 uvOffset = to2DTextureCoordinates(uvwOffset);\n    vec4 b = boundaryValue(uvOffset, uvwOffset);\n    return b*texture2D(tex, uvOffset);\n}\n\nvec4 valueAt(sampler2D tex, int orientation, int i) {\n    if (orientation == X_ORIENTATION)\n        return valueAt(tex, i, 0, 0);\n    else if (orientation == Y_ORIENTATION)\n        return valueAt(tex, 0, i, 0);\n    else\n        return valueAt(tex, 0, 0, i);\n}\n\nvec4 centredDiff(sampler2D tex, int i) {\n    vec4 b = boundaryValue(UV, to3DTextureCoordinates(UV));\n    if (staggeredMode >= 1) {\n        return b*(valueAt(tex, i, 1)\n                  - valueAt(tex, i, 0))/dr[i];\n    } else if (staggeredMode == 0) {\n        if (orderOfAccuracy >= 4)\n            return b*((1.0/12.0)*valueAt(tex, i, -2) \n                    - (2.0/3.0)*valueAt(tex, i, -1)\n                    + (2.0/3.0)*valueAt(tex, i, 1)\n                    - (1.0/12.0)*valueAt(tex, i, 2)\n                   )/dr[i];\n        else\n            return 0.5*b*(valueAt(tex, i, 1)\n                          - valueAt(tex, i, -1))/dr[i];\n    } else if (staggeredMode <= -1) {\n        return b*(valueAt(tex, i, 0)\n                  - valueAt(tex, i, -1))/dr[i];\n    }\n}\n\n\n/* vec4 centredXDiff(sampler2D tex) {\n    // The destination texture is staggered foward relative to the source\n    // texture\n    if (staggeredMode >= 1) {\n    } else if (staggeredMode == 0) {\n        if (orderOfAccuracy >= 4)\n            return (  (1.0/12.0)*valueAt(tex, -2, 0, 0)\n                    - (2.0/3.0)*valueAt(tex, -1, 0, 0)\n                    + (2.0/3.0)*valueAt(tex,  1, 0, 0)\n                    - (1.0/12.0)*valueAt(tex,  2, 0, 0)\n                )/dr.x;\n        else\n            return 0.5*(valueAt(tex, 1, 0, 0) - valueAt(tex, -1, 0, 0))/dr.x;\n    } else if (staggeredMode <= -1) {\n\n    }\n}\n\nvec4 centredYDiff(sampler2D tex) {\n    if (orderOfAccuracy >= 4)\n        return (  (1.0/12.0)*valueAt(tex, 0, -2, 0)\n                - (2.0/3.0)*valueAt(tex, 0, -1, 0)\n                + (2.0/3.0)*valueAt(tex, 0,  1, 0)\n                - (1.0/12.0)*valueAt(tex, 0,  2, 0)\n               )/dr.y;\n    else\n        return 0.5*(valueAt(tex, 0, 1, 0) - valueAt(tex, 0, -1, 0))/dr.y;\n}\n\nvec4 centredZDiff(sampler2D tex) {\n    if (orderOfAccuracy >= 4)\n        return (  (1.0/12.0)*valueAt(tex, 0, 0, -2)\n                - (2.0/3.0)*valueAt(tex, 0, 0, -1)\n                + (2.0/3.0)*valueAt(tex, 0, 0,  1)\n                - (1.0/12.0)*valueAt(tex, 0, 0,  2)\n               )/dr.z;\n    else\n        return 0.5*(valueAt(tex, 0, 0, 1) - valueAt(tex, 0, 0, -1))/dr.z;\n}*/\n\nvoid main() {\n    vec4 dTexdx = centredDiff(tex, X_ORIENTATION);\n    vec4 dTexdy = centredDiff(tex, Y_ORIENTATION);\n    vec4 dTexdz = centredDiff(tex, Z_ORIENTATION);\n    fragColor = vec4(dTexdx[index], dTexdy[index], dTexdz[index], 1.0); \n}\n`;
shaders[`./shaders/init-wavepacket/gaussian.frag`] = `/* Generate a new wavepacket. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\ncomplex mul(complex a, complex b) {\n    return complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// wave number of the wave packet (w.r.t. simulation domains)\nuniform vec2 waveNumber;\n// Position Offset of the wave packet in texture coordinates\nuniform vec2 texOffset;\n// Amplitude of the wave packet\nuniform float amplitude;\n// Standard deviation of the wave packet, in texture coordinates\nuniform vec2 sigmaXY;\n\ncomplex wavepacket(vec2 r) {\n    float sx = sigmaXY.x;\n    float sy = sigmaXY.y;\n    float gx = exp(-0.25*pow(r.x/sx, 2.0))/sqrt(sx*sqrt(2.0*PI));\n    float gy = exp(-0.25*pow(r.y/sy, 2.0))/sqrt(sy*sqrt(2.0*PI));\n    float g = gx*gy;\n    float nx = waveNumber.x;\n    float ny = waveNumber.y;\n    complex phase = complex(cos(2.0*PI*(nx*r.x + ny*r.y)),\n                            sin(2.0*PI*(nx*r.x + ny*r.y)));\n    return amplitude*g*phase;\n}\n\nvoid main() {\n    float x = UV.x;\n    float y = UV.y;\n    float x0 = texOffset.x;\n    float y0 = texOffset.y;\n    vec2 r = vec2(x - x0, y - y0);\n    complex w = wavepacket(r)\n        + wavepacket(vec2(r.x + 1.0, r.y)) \n        + wavepacket(vec2(r.x - 1.0, r.y)) \n        + wavepacket(vec2(r.x, r.y + 1.0))\n        + wavepacket(vec2(r.x, r.y - 1.0))\n        + wavepacket(vec2(r.x - 1.0, r.y - 1.0))\n        + wavepacket(vec2(r.x + 1.0, r.y + 1.0))\n        + wavepacket(vec2(r.x + 1.0, r.y - 1.0))\n        + wavepacket(vec2(r.x - 1.0, r.y + 1.0));\n    fragColor = vec4(w, w);\n}\n`;
shaders[`./shaders/init-wavepacket/gaussian3d.frag`] = `/* Generate a new wavepacket. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\ncomplex mul(complex a, complex b) {\n    return complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nuniform float amplitude;\nuniform vec3 waveNumber;\nuniform vec3 texOffset;\nuniform vec3 sigma;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\ncomplex wavepacket(vec3 r) {\n    float sx = sigma.x;\n    float sy = sigma.y;\n    float sz = sigma.z;\n    float gx = exp(-0.25*pow(r.x/sx, 2.0))/sqrt(sx*sqrt(2.0*PI));\n    float gy = exp(-0.25*pow(r.y/sy, 2.0))/sqrt(sy*sqrt(2.0*PI));\n    float gz = exp(-0.25*pow(r.z/sz, 2.0))/sqrt(sz*sqrt(2.0*PI));\n    float g = gx*gy*gz;\n    complex phase = complex(cos(2.0*PI*dot(waveNumber, r)),\n                            sin(2.0*PI*dot(waveNumber, r)));\n    return amplitude*g*phase;\n}\n\nvoid main() {\n    vec3 r = to3DTextureCoordinates(UV) - texOffset;\n    complex w =\n        + wavepacket(vec3(r.x + (-1.0), r.y + (-1.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (-1.0), r.y + (-1.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (-1.0), r.y + (-1.0), r.z + (1.0)))\n        + wavepacket(vec3(r.x + (-1.0), r.y + (0.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (-1.0), r.y + (0.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (-1.0), r.y + (0.0), r.z + (1.0)))\n        + wavepacket(vec3(r.x + (-1.0), r.y + (1.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (-1.0), r.y + (1.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (-1.0), r.y + (1.0), r.z + (1.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (-1.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (-1.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (-1.0), r.z + (1.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (0.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (0.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (0.0), r.z + (1.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (1.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (1.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (0.0), r.y + (1.0), r.z + (1.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (-1.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (-1.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (-1.0), r.z + (1.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (0.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (0.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (0.0), r.z + (1.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (1.0), r.z + (-1.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (1.0), r.z + (0.0)))\n        + wavepacket(vec3(r.x + (1.0), r.y + (1.0), r.z + (1.0)))\n        ;\n    fragColor = vec4(w, w.r, w.r);\n}\n`;
shaders[`./shaders/init-wavepacket/sech.frag`] = `/* Generate a new wavepacket. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\ncomplex mul(complex a, complex b) {\n    return complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// wave number of the wave packet (w.r.t. simulation domains)\nuniform vec2 waveNumber;\n// Position Offset of the wave packet in texture coordinates\nuniform vec2 texOffset;\n// Amplitude of the wave packet\nuniform float amplitude;\n// Standard deviation of the wave packet, in texture coordinates\nuniform vec2 sigmaXY;\n\n#if (__VERSION__ < 130)\n\nfloat cosh(float x) {\n    return (exp(x) + exp(-x))/2.0;\n}\n\n#endif\n\ncomplex wavepacket(vec2 r) {\n    float sx = sigmaXY.x;\n    float sy = sigmaXY.y;\n    float gx = 1.0/cosh(-0.25*pow(r.x/sx, 2.0))/sqrt(sx*sqrt(2.0*PI));\n    float gy = 1.0/cosh(-0.25*pow(r.y/sy, 2.0))/sqrt(sy*sqrt(2.0*PI));\n    float g = gx*gy;\n    float nx = waveNumber.x;\n    float ny = waveNumber.y;\n    complex phase = complex(cos(2.0*PI*(nx*r.x + ny*r.y)),\n                            sin(2.0*PI*(nx*r.x + ny*r.y)));\n    return amplitude*g*phase;\n}\n\nvoid main() {\n    float x = UV.x;\n    float y = UV.y;\n    float x0 = texOffset.x;\n    float y0 = texOffset.y;\n    vec2 r = vec2(x - x0, y - y0);\n    complex w = wavepacket(r)\n        + wavepacket(vec2(r.x + 1.0, r.y)) \n        + wavepacket(vec2(r.x - 1.0, r.y)) \n        + wavepacket(vec2(r.x, r.y + 1.0))\n        + wavepacket(vec2(r.x, r.y - 1.0))\n        + wavepacket(vec2(r.x - 1.0, r.y - 1.0))\n        + wavepacket(vec2(r.x + 1.0, r.y + 1.0))\n        + wavepacket(vec2(r.x + 1.0, r.y - 1.0))\n        + wavepacket(vec2(r.x - 1.0, r.y + 1.0));\n    fragColor = vec4(w, w);\n}\n`;
shaders[`./shaders/sketch/potential.frag`] = `/* Shader for sketching a potential */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform vec2 location;\nuniform float amplitude;\nuniform vec2 sigmaXY;\n\nvoid main() {\n    complex oldVal = texture2D(tex, UV).xy;\n    float x0 = location.x;\n    float y0 = location.y;\n    float sigmaX = sigmaXY[0];\n    float sigmaY = sigmaXY[1];\n    float x = UV.x;\n    float y = UV.y;\n    float gx = exp(-0.5*(x - x0)*(x - x0)/(sigmaX*sigmaX));\n    float gy = exp(-0.5*(y - y0)*(y - y0)/(sigmaY*sigmaY));\n    complex newVal = oldVal + amplitude*complex(gx*gy, 0.0);\n    if (newVal.x > 2.0)\n        newVal.x = (oldVal.x < 2.0)? 2.0: oldVal.x;\n    if (newVal.x < 0.0)\n        newVal.x = (oldVal.x > 0.0)? 0.0: oldVal.x; \n    fragColor = vec4(newVal, newVal);\n\n}\n`;
shaders[`./shaders/sketch/potential3d.frag`] = `/* Shader for sketching a potential */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform vec3 location;\nuniform float amplitude;\nuniform vec3 sigma;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    complex oldVal = texture2D(tex, UV).xy;\n    float x0 = location.x;\n    float y0 = location.y;\n    float z0 = location.z;\n    float sigmaX = sigma[0];\n    float sigmaY = sigma[1];\n    float sigmaZ = sigma[2];\n    vec3 xyz = to3DTextureCoordinates(UV);\n    float x = xyz.x, y = xyz.y, z = xyz.z;\n    float gx = exp(-0.5*(x - x0)*(x - x0)/(sigmaX*sigmaX));\n    float gy = exp(-0.5*(y - y0)*(y - y0)/(sigmaY*sigmaY));\n    float gz = exp(-0.5*(z - z0)*(z - z0)/(sigmaZ*sigmaZ));\n    complex newVal = oldVal + amplitude*complex(gx*gy*gz, 0.0);\n    if (newVal.x > 2.0)\n        newVal.x = (oldVal.x < 2.0)? 2.0: oldVal.x;\n    if (newVal.x < 0.0)\n        newVal.x = (oldVal.x > 0.0)? 0.0: oldVal.x; \n    fragColor = vec4(newVal, newVal);\n\n}\n`;
shaders[`./shaders/slices/planar-slice.vert`] = `#if __VERSION__ <= 120\nattribute vec3 position;\nvarying vec2 UV;\n#else\nin vec3 position;\nout vec2 UV;\n#endif\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#define quaternion vec4\n\nuniform vec3 offset;\nuniform float scale;\nuniform quaternion rotation;\nuniform ivec2 screenDimensions;\n    \nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion q) {\n    return quaternion(-q.x, -q.y, -q.z, q.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    return quaternion(mul(conj(r), mul(x, r)).xyz, 1.0);\n}\n\nvec4 project(vec4 x) {\n    vec4 y;\n    y[0] = x[0]*4.0/(x[2] + 4.0);\n    y[1] = float(screenDimensions[0])/float(screenDimensions[1])\n            *x[1]*4.0/(x[2] + 4.0);\n    y[2] = x[2]/4.0;\n    y[3] = 1.0;\n    return y;\n}\n\nvoid main() {\n    UV = position.xy/2.0 + vec2(0.5, 0.5);\n    gl_Position = rotate(quaternion(scale*(position + offset), 1.0),\n                         rotation);\n}\n\n`;
shaders[`./shaders/slices/quartered-square-outline.vert`] = `#if __VERSION__ <= 120\nattribute vec3 position;\nvarying vec2 UV; //Not actually used!\n#else\nin vec3 position;\nout vec2 UV;\n#endif\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#define quaternion vec4\n\nuniform vec3 cursorPosition;\nuniform vec3 offset;\nuniform float scale;\nuniform quaternion rotation;\nuniform ivec2 screenDimensions;\n\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion q) {\n    return quaternion(-q.x, -q.y, -q.z, q.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    return quaternion(mul(conj(r), mul(x, r)).xyz, 1.0);\n}\n\nvec4 project(vec4 x) {\n    vec4 y;\n    y[0] = x[0]*4.0/(x[2] + 4.0);\n    y[1] = float(screenDimensions[0])/float(screenDimensions[1])\n            *x[1]*4.0/(x[2] + 4.0);\n    y[2] = x[2]/4.0;\n    y[3] = 1.0;\n    return y;\n}\n\nvoid main() {\n    vec3 position2 = position;\n    // Make the center vertex have the same position\n    // as the cursor.\n    if (abs(position.x) < 1e-30 && abs(position.y) < 1e-30) {\n        position2 = cursorPosition;\n    } else if (position.x == 0.0) {\n        // Adjust the other vertices of the "cross" as well.\n        position2.x = cursorPosition.x;\n    } else if (position.y == 0.0) {\n        position2.y = cursorPosition.y;\n    }\n    UV = position2.xy/2.0 + vec2(0.5, 0.5);\n    gl_Position = rotate(quaternion(scale*(position2 + offset), 1.0),\n                         rotation);\n}\n`;
shaders[`./shaders/split-step/dirac-kinetic.frag`] = `/* The Dirac equation using an arbitrary four-vector potential and\nwith constants like c and hbar explicitly written out can be found\non pg 566 (eq. 20.2.2) of Principles of Quantum Mechanics by Shankar.\n\n The Split Operator momentum space propagator for the Dirac equation \n in the Dirac representation is derived in II.3 of this article\n by Bauke and Keitel: https://arxiv.org/abs/1012.3911.\n To derive the momentum space propagator in the Weyl representation,\n the gamma matrices as given on (3.25) in pg. 41 of \n An Introduction to Quantum Field Theory \n by Michael Peskin and Daniel Schroeder are used.\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform int numberOfDimensions;\nuniform ivec2 texelDimensions2D;\nuniform vec2 dimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\n\nuniform sampler2D uTex;\nuniform sampler2D vTex;\nuniform float dt;\nuniform float m;\nuniform float c;\nuniform float hbar;\n\nuniform int spinorIndex;\nconst int TOP = 0;\nconst int BOTTOM = 1;\n\nconst int DIRAC_REP = 0;\nconst int WEYL_REP = 1;\nuniform int representation;\n\n#define complex vec2\n#define complex2 vec4\n\nconst float PI = 3.141592653589793;\n\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\ncomplex mul(complex z1, complex z2) {\n    return complex(z1.x*z2.x - z1.y*z2.y, \n                   z1.x*z2.y + z1.y*z2.x);\n}\n\ncomplex conj(complex z) {\n    return vec2(z.x, -z.y);\n}\n\ncomplex innerProd(complex2 z1, complex2 z2) {\n    return mul(conj(z1.rg), z2.rg) + mul(conj(z1.ba), z2.ba);\n}\n\n/* Multiply a complex scalar c1 with a two-component complex vector c2.*/\ncomplex2 c1C2(complex c1, complex2 c2) {\n    complex a = complex(c2[0], c2[1]);\n    complex b = complex(c2[2], c2[3]);\n    return complex2(complex(c1.x*a.x - c1.y*a.y, c1.x*a.y + c1.y*a.x),\n                    complex(c1.x*b.x - c1.y*b.y, c1.x*b.y + c1.y*b.x));\n}\n\n\ncomplex frac(complex z1, complex z2) {\n    complex invZ2 = conj(z2)/(z2.x*z2.x + z2.y*z2.y);\n    return mul(z1, invZ2);\n}\n\nvec3 getMomentum() {\n    float u, v, w;\n    float width, height, length_;\n    int texelWidth, texelHeight, texelLength;\n    if (numberOfDimensions == 3) {\n        width = dimensions3D[0];\n        height = dimensions3D[1];\n        length_ = dimensions3D[2];\n        texelWidth = texelDimensions3D[0];\n        texelHeight = texelDimensions3D[1];\n        texelLength = texelDimensions3D[2];\n        vec3 uvw = to3DTextureCoordinates(UV);\n        u = uvw[0], v = uvw[1], w = uvw[2];\n    } else {\n        width = dimensions2D[0];\n        height = dimensions2D[1];\n        length_ = 0.0;\n        texelWidth = texelDimensions2D[0];\n        texelHeight = texelDimensions2D[1];\n        texelLength = 0;\n        u = UV[0], v = UV[1], w = 0.0;\n    }\n    float freqU = ((u < 0.5)? u: -1.0 + u)*float(texelWidth) - 0.5;\n    float freqV = ((v < 0.5)? v: -1.0 + v)*float(texelHeight) - 0.5;\n    float freqW = ((w < 0.5)? w: -1.0 + w)*float(texelLength) - 0.5;\n    return vec3(2.0*PI*freqU/width, 2.0*PI*freqV/height, \n                2.0*PI*freqW/length_);\n}\n\n/*Compute the spin up eigenvector for a Pauli matrix oriented in an\narbitrary direction. Although easily double by pencil and paper,\nthis was instead done using \nPython with [Sympy](https://www.sympy.org/en/index.html).\nThe representation used for the Pauli matrices are found here:\nhttps://en.wikipedia.org/wiki/Pauli_matrices.\n\n>>> from sympy import Symbol, sqrt\n>>> from sympy import Matrix\n>>> nx = Symbol('nx', real=True)\n>>> ny = Symbol('ny', real=True)\n>>> nz = Symbol('nz', real=True)\n>>> n = sqrt(nx**2 + ny**2 + nz**2)\n>>> H = Matrix([[nz, nx - 1j*ny],\n>>>             [nx + 1j*ny, -nz]])\n>>> eigvects, diag_matrix = H.diagonalize(normalize=True)\n>>> eigvects = eigvects.subs(n, 'n')\n>>> print(eigvects, diag_matrix)\n\n*/\ncomplex2 getSpinUpState(vec3 orientation, float len) {\n    float n = len;\n    float nx = orientation.x, ny = orientation.y, nz = orientation.z;\n    complex az = complex(1.0, 0.0);\n    complex bz = complex(0.0, 0.0);\n    complex a = frac(complex(n + nz, 0.0),\n                     complex(nx, ny)*sqrt((nz + n)*(nz + n)/(nx*nx + ny*ny)\n                                          + 1.0));\n    complex b = complex(1.0/sqrt((nz + n)*(nz + n)/(nx*nx + ny*ny) + 1.0),\n                        0.0);\n    if ((nx*nx + ny*ny) == 0.0)\n        return complex2(az, bz);\n    return complex2(a, b);\n}\n\n/*Compute the spin down eigenvector for a Pauli matrix oriented in an\narbitrary direction. See documentation for getSpinUpState for more \ninformation.*/\ncomplex2 getSpinDownState(vec3 orientation, float len) {\n    float n = len;\n    float nx = orientation.x, ny = orientation.y, nz = orientation.z;\n    complex az = complex(0.0, 0.0);\n    complex bz = complex(1.0, 0.0);\n    complex a = frac(complex(-n + nz, 0.0),\n                     complex(nx, ny)*sqrt((nz - n)*(nz - n)/(nx*nx + ny*ny)\n                                          + 1.0));\n    complex b = complex(1.0/sqrt((nz - n)*(nz - n)/(nx*nx + ny*ny) + 1.0),\n                        0.0);\n    if ((nx*nx + ny*ny) == 0.0)\n        return complex2(az, bz);\n    return complex2(a, b);\n}\n\nfloat pow2(float val) {\n    return val*val;\n} \n\n/*\nFind the eigenvalues of a real symmetric 2x2 matrix.\nThe argument i indexes which eigenvalue to get, \nwhile d0 and d1 denote the top and bottom diagonal elements respectively.\nThe variable nd corresponds to the non-diagonal element.\n\nIt is assumed that the eigenvalues of the matrix is purely real,\nwhich implies that \n    d0*d0 - 2*d0*d1 + d1*d1 + 4*nd*nd > 0.\n\nThe eigenvalues and eigenvectors are found using Python\nwith [Sympy](https://www.sympy.org/en/index.html):\n\n>>> from sympy import Matrix\n>>> from sympy import Symbol\n>>> d0 = Symbol('d0', real=True)\n>>> d1 = Symbol('d1', real=True)\n>>> nd = Symbol('nd', real=True)\n>>> mat = Matrix([[d0, nd], [nd, d1]])\n>>> mat_eigenvects = mat.eigenvects()\n>>> for eig_info in mat_eigenvects:\n>>>     eigval, degeneracy, eigvects = eig_info\n>>>     print('Eigenvalue: ', eigval, '\nDegeneracy: ', degeneracy)\n>>>     for eigvect in eigvects:\n>>>         eigvect_normalized = eigvect/eigvect.norm()\n>>>         eigvect_normalized.simplify()\n>>>         print(eigvect_normalized)\n>>>         print()\n\n*/\nfloat eigenvalueRealSymmetric2x2(int i, float d0, float d1, float nd) {\n    if (nd == 0.0)\n        return (i == 0)? d0: d1;\n    if (i == 0)\n        return d0/2.0 + d1/2.0\n                 - sqrt(d0*d0 - 2.0*d0*d1 + d1*d1 + 4.0*nd*nd)/2.0;\n    else\n        return d0/2.0 + d1/2.0 \n                 + sqrt(d0*d0 - 2.0*d0*d1 + d1*d1 + 4.0*nd*nd)/2.0;\n}\n\n/*\nFind the eigenvectors of a real symmetric 2x2 matrix.\nThe argument i indexes which eigenvector to get, \nwhile d0 and d1 denote the top and bottom diagonal elements respectively.\nThe variable nd corresponds to the non-diagonal element.\n\nIt is assumed that the eigenvalues of the matrix is purely real,\nwhich implies that \n    d0*d0 - 2*d0*d1 + d1*d1 + 4*nd*nd > 0.\n\nThe eigenvalues and eigenvectors are found using Python\nwith [Sympy](https://www.sympy.org/en/index.html):\n\n>>> from sympy import Matrix\n>>> from sympy import Symbol\n>>> d0 = Symbol('d0', real=True)\n>>> d1 = Symbol('d1', real=True)\n>>> nd = Symbol('nd', real=True)\n>>> mat = Matrix([[d0, nd], [nd, d1]])\n>>> mat_eigenvects = mat.eigenvects()\n>>> for eig_info in mat_eigenvects:\n>>>     eigval, degeneracy, eigvects = eig_info\n>>>     print('Eigenvalue: ', eigval, '\nDegeneracy: ', degeneracy)\n>>>     for eigvect in eigvects:\n>>>         eigvect_normalized = eigvect/eigvect.norm()\n>>>         eigvect_normalized.simplify()\n>>>         print(eigvect_normalized)\n>>>         print()\n\n*/\nvec2 eigenvectorRealSymmetric2x2(int i, float d0, float d1, float nd) {\n    if (nd == 0.0)\n        return (i == 0)? vec2(1.0, 0.0): vec2(0.0, 1.0);\n    if (i == 0)\n        return vec2(\n            (d0 - d1 - sqrt(d0*d0 - 2.0*d0*d1 + d1*d1 + 4.0*nd*nd))\n             / (nd*sqrt(pow2((-d0 + d1\n                              + sqrt(d0*d0 - 2.0*d0*d1 + d1*d1 + 4.0*nd*nd)\n                             )/nd\n                            ) + 4.0\n                        )\n                ),\n            2.0/sqrt(pow2((-d0 + d1\n                           + sqrt(d0*d0 - 2.0*d0*d1 + d1*d1 + 4.0*nd*nd)\n                          )/nd\n                          ) + 4.0)\n        );\n    else\n        return vec2(\n            (d0 - d1 + sqrt(d0*d0 - 2.0*d0*d1 + d1*d1 + 4.0*nd*nd))\n             / (nd*sqrt(pow2((d0 - d1 \n                              + sqrt(d0*d0 - 2.0*d0*d1 + d1*d1 + 4.0*nd*nd)\n                             )/nd\n                            ) + 4.0\n                        )\n                ),\n            2.0/sqrt(pow2((d0 - d1\n                           + sqrt(d0*d0 - 2.0*d0*d1 + d1*d1 + 4.0*nd*nd)\n                          )/nd\n                          ) + 4.0)\n        );\n}\n\nvoid main() {\n\n    vec3 pVec = getMomentum();\n    float px = pVec.x, py = pVec.y, pz = pVec.z;\n    float p2 = px*px + py*py + pz*pz;\n    float p = sqrt(p2);\n    float mc = m*c;\n\n    // Get the eigenvectors of that Pauli matrix that is\n    // orientated in the same direction as the momentum\n    complex2 up = getSpinUpState(pVec, p);\n    complex2 down = getSpinDownState(pVec, p);\n\n    // Scaled eigenvalues of the kinetic energy matrix for the given momenta.\n    float e0, e1, e2, e3;\n\n    vec2 vUp0, vUp1, vDown0, vDown1;\n    // These will be used to compute the actual corresponding eigenvectors\n    // of the eigenvalues declared previously.\n\n    if (representation == DIRAC_REP) {\n\n        // Suggestion: note that for the second and third arguments \n        // of the function eigenvalueRealSymmetric2x2, d0 and d1,\n        // the relation d0 + d1 = 0 always holds for this system.\n        // Use this to do some further simplifications to the problem\n        // at hand.\n        e0 = eigenvalueRealSymmetric2x2(0, mc, -mc, p);\n        vUp0 = eigenvectorRealSymmetric2x2(0, mc, -mc, p);\n        e1 = eigenvalueRealSymmetric2x2(1, mc, -mc, p);\n        vUp1 = eigenvectorRealSymmetric2x2(1, mc, -mc, p);\n        e2 = eigenvalueRealSymmetric2x2(0, mc, -mc, -p);\n        vDown0 = eigenvectorRealSymmetric2x2(0, mc, -mc, -p);\n        e3 = eigenvalueRealSymmetric2x2(1, mc, -mc, -p);\n        vDown1 = eigenvectorRealSymmetric2x2(1, mc, -mc, -p);\n\n    } else if (representation == WEYL_REP) {\n\n        e0 = eigenvalueRealSymmetric2x2(0, -p, p, mc);\n        vUp0 = eigenvectorRealSymmetric2x2(0, -p, p, mc);\n        e1 = eigenvalueRealSymmetric2x2(1, -p, p, mc);\n        vUp1 = eigenvectorRealSymmetric2x2(1, -p, p, mc);\n        e2 = eigenvalueRealSymmetric2x2(0, p, -p, mc);\n        vDown0 = eigenvectorRealSymmetric2x2(0, p, -p, mc);\n        e3 = eigenvalueRealSymmetric2x2(1, p, -p, mc);\n        vDown1 = eigenvectorRealSymmetric2x2(1, p, -p, mc);\n    }\n\n    // Compute the eigenvectors of the kinetic energy matrix for\n    // the given momentum.\n    // Note that v00 denotes the first 2 components of the v0 eigenvector,\n    // and v01 the last two. Likewise v1 is split into v10 and v11,\n    // v2 into v20 and v21, and v3 into v30 and v31.\n    complex2 v00 = vUp0[0]*up,     v01 = vUp0[1]*up; \n    complex2 v10 = vUp1[0]*up,     v11 = vUp1[1]*up;\n    complex2 v20 = vDown0[0]*down, v21 = vDown0[1]*down;\n    complex2 v30 = vDown1[0]*down, v31 = vDown1[1]*down;\n\n    // Get each bispinor component of the wave function\n    complex2 psi0 = texture2D(uTex, UV);\n    complex2 psi1 = texture2D(vTex, UV);\n\n    // Using the eigenvectors of the kinetic energy matrix\n    // for the given momenta, express the wave function in terms\n    // of it.\n    complex d0 = innerProd(v00, psi0) + innerProd(v01, psi1);\n    complex d1 = innerProd(v10, psi0) + innerProd(v11, psi1);\n    complex d2 = innerProd(v20, psi0) + innerProd(v21, psi1);\n    complex d3 = innerProd(v30, psi0) + innerProd(v31, psi1);\n\n    // Advance the wave function in time\n    d0 = mul(complex(cos(e0*c*dt/hbar), -sin(e0*c*dt/hbar)), d0);\n    d1 = mul(complex(cos(e1*c*dt/hbar), -sin(e1*c*dt/hbar)), d1);\n    d2 = mul(complex(cos(e2*c*dt/hbar), -sin(e2*c*dt/hbar)), d2);\n    d3 = mul(complex(cos(e3*c*dt/hbar), -sin(e3*c*dt/hbar)), d3); \n\n    // Transform the wave function back to its initial representation\n    psi0 = c1C2(d0, v00) + c1C2(d1, v10) + c1C2(d2, v20) + c1C2(d3, v30);\n    psi1 = c1C2(d0, v01) + c1C2(d1, v11) + c1C2(d2, v21) + c1C2(d3, v31);\n\n    fragColor = (spinorIndex == TOP)? psi0: psi1;\n\n}\n\n`;
shaders[`./shaders/split-step/kinetic.frag`] = `/* GLSL implementation of the momentum step for the split operator algorithm\n\nReferences:\n\nSplit-Operator Method:\nJames Schloss. The Split Operator Method - Arcane Algorithm Archive.\nhttps://www.algorithm-archive.org/contents/split-operator_method/\n split-operator_method.html\n*/\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform int numberOfDimensions;\nuniform ivec2 texelDimensions2D;\nuniform vec2 dimensions2D;\nuniform ivec3 texelDimensions3D;\nuniform vec3 dimensions3D;\n\n#define complex vec2\n#define complex2 vec4\n\nconst float PI = 3.141592653589793;\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\nuniform complex dt;\nuniform float m;\nuniform float hbar;\nuniform sampler2D psiTex;\nuniform bool useCustomKETex;\nuniform sampler2D customKETex;\n\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\ncomplex mul(complex z, float r) {\n    return r*z;\n}\n\ncomplex mul(float r, complex z) {\n    return mul(z, r);\n}\n\ncomplex mul(complex z1, complex z2) {\n    return complex(z1.x*z2.x - z1.y*z2.y, \n                   z1.x*z2.y + z1.y*z2.x);\n}\n\ncomplex expC(complex z) {\n    return complex(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));\n}\n\nvec3 getMomentum() {\n    float u, v, w;\n    float width, height, length_;\n    int texelWidth, texelHeight, texelLength;\n    if (numberOfDimensions == 3) {\n        width = dimensions3D[0];\n        height = dimensions3D[1];\n        length_ = dimensions3D[2];\n        texelWidth = texelDimensions3D[0];\n        texelHeight = texelDimensions3D[1];\n        texelLength = texelDimensions3D[2];\n        vec3 uvw = to3DTextureCoordinates(UV);\n        u = uvw[0], v = uvw[1], w = uvw[2];\n    } else {\n        width = dimensions2D[0];\n        height = dimensions2D[1];\n        length_ = 0.0;\n        texelWidth = texelDimensions2D[0];\n        texelHeight = texelDimensions2D[1];\n        texelLength = 0;\n        u = UV[0], v = UV[1], w = 0.0;\n    }\n    float freqU = ((u < 0.5)? u: -1.0 + u)*float(texelWidth) - 0.5;\n    float freqV = ((v < 0.5)? v: -1.0 + v)*float(texelHeight) - 0.5;\n    float freqW = ((w < 0.5)? w: -1.0 + w)*float(texelLength) - 0.5;\n    return vec3(2.0*PI*freqU/width, 2.0*PI*freqV/height, \n                (numberOfDimensions == 3)? 2.0*PI*freqW/length_: 0.0);\n}\n\nvoid main() {\n    complex2 psi = texture2D(psiTex, UV);\n    complex psi1 = psi.xy;\n    complex psi2 = psi.zw;\n    complex idt = mul(IMAG_UNIT, dt);\n    if (useCustomKETex) {\n        complex kineticEnergy = texture2D(customKETex, UV).xy;\n        fragColor = vec4(mul(expC(-mul(idt, kineticEnergy)/hbar), psi1),\n                         mul(expC(-mul(idt, kineticEnergy)/hbar), psi2));\n    } else {\n        vec3 p = getMomentum();\n        float p2 = p.x*p.x + p.y*p.y + p.z*p.z;\n        fragColor = vec4(mul(expC(-idt*p2/(2.0*m*hbar)), psi1),\n                         mul(expC(-idt*p2/(2.0*m*hbar)), psi2));\n    }\n\n}`;
shaders[`./shaders/split-step/spatial.frag`] = `/* GLSL implementation of the spatial step \n(that exponential term which only depends on position)\n for the split operator algorithm\n\nReferences:\n\nSplit-Operator Method:\nJames Schloss. The Split Operator Method - Arcane Algorithm Archive.\nhttps://www.algorithm-archive.org/contents/split-operator_method/\n split-operator_method.html\n \n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n#define complex2 vec4\n\nconst complex IMAG_UNIT = complex(0.0, 1.0);\n\nuniform complex dt;\nuniform float m;\nuniform float hbar;\nuniform sampler2D potentialTex;\nuniform sampler2D psiTex;\n\n\ncomplex mul(complex z1, complex z2) {\n    return complex(z1.x*z2.x - z1.y*z2.y, \n                   z1.x*z2.y + z1.y*z2.x);\n}\n\ncomplex expC(complex z) {\n    return complex(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));\n}\n\n\nvoid main() {\n    complex2 psi = texture2D(psiTex, UV);\n    complex psi1 = psi.xy;\n    complex psi2 = psi.zw;\n    complex potential = texture2D(potentialTex, UV).xy;\n    complex iVdt = mul(IMAG_UNIT, mul(potential, dt));\n    if (potential.x == 0.0 && potential.y == 0.0) {\n        fragColor = vec4(psi1, psi2);\n    } else {\n        fragColor = vec4(mul(expC(-iVdt/hbar), psi1),\n                        mul(expC(-iVdt/hbar), psi2));\n    }\n}\n`;
shaders[`./shaders/surface/domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\nvarying vec3 NORMAL;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nin vec3 NORMAL;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    float ambient = 0.01;\n    // float diffuse = abs(dot(NORMAL, vec3(0.0, 0.0, -1.0)));\n    float brightness2 = brightness*length(z2);\n    vec3 color = ambient \n        + (\n            1.0 // + diffuse\n        )*brightness2*argumentToColor(atan(z2.y, z2.x));\n    // fragColor = vec4(color, min(1.0, 10.0*brightness2));\n    fragColor = vec4(color, 1.0);\n}\n`;
shaders[`./shaders/surface/single-color.frag`] = `/* Output a single colour for every texel of the output texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\nvarying vec3 FINAL_VERTEX_POSITION;\nvarying vec3 NORMAL;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nin vec3 NORMAL;\nin vec3 FINAL_VERTEX_POSITION;\nout vec4 fragColor;\n#endif\n\nuniform vec4 color;\n\nvoid main() {\n    vec3 lightSourceLoc = vec3(0.0, 0.0, -3.0);\n    vec3 vertexToLightSource = lightSourceLoc - FINAL_VERTEX_POSITION;\n    float diffuse1 = max(dot(NORMAL, normalize(vertexToLightSource)), 0.0);\n    float diffuse2 =  max(dot(-NORMAL, normalize(vertexToLightSource)), 0.0);\n    // float diffuse2 = max(0.5*dot(NORMAL, vec3(0.0, 0.0, -1.0)), 0.0); \n    float diffuse = ((NORMAL.z < 0.0)? diffuse1: diffuse2);\n    fragColor = vec4(color.rgb*(diffuse), color.a);\n}\n`;
shaders[`./shaders/surface/vert.vert`] = ` \n#if __VERSION__ <= 120\nattribute vec2 position;\nvarying vec2 UV;\nvarying vec3 FINAL_VERTEX_POSITION;\nvarying vec3 NORMAL;\n#else\nin vec2 position;\nout vec2 UV;\nout vec3 FINAL_VERTEX_POSITION;\nout vec3 NORMAL;\n#endif\n\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n\n#define quaternion vec4\n\nuniform sampler2D heightTex;\nuniform quaternion rotation;\nuniform ivec2 screenDimensions;\nuniform vec3 translate;\nuniform float heightScale;\nuniform float scale;\nuniform ivec2 dimensions2D;\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion q) {\n    return quaternion(-q.x, -q.y, -q.z, q.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    return quaternion(mul(conj(r), mul(x, r)).xyz, 1.0);\n}\n\nvec4 project(vec4 x) {\n    vec4 y;\n    y[0] = x[0]*4.0/(x[2] + 4.0);\n    y[1] = float(screenDimensions[0])/float(screenDimensions[1])\n            *x[1]*4.0/(x[2] + 4.0);\n    y[2] = x[2]/4.0;\n    y[3] = 1.0;\n    return y;\n}\n\nvec3 getNormal(vec2 xy) {\n    float x = xy[0], y = xy[1];\n    float dx = 1.0/float(dimensions2D[0]);\n    float dy = 1.0/float(dimensions2D[1]);\n    float height = heightScale*texture2D(\n        heightTex, xy)[0];\n    float heightR = heightScale*texture2D(\n        heightTex, xy + vec2(dx, 0.0))[0];\n    float heightU = heightScale*texture2D(\n        heightTex, xy + vec2(0.0, dy))[0];\n    vec3 vC = vec3(x, y, height);\n    vec3 vR = vec3(x + dx, y, heightR);\n    vec3 vU = vec3(x, y + dy, heightU);\n    vec3 eU = vU - vC;\n    vec3 eR = vR - vC;\n    /* Note that since the z-axis points away from the screen,\n    and that the surface height map is inverted in the other direction,\n    these normal vectors point into the surface instead of away.\n    */\n    return normalize(mul(quaternion(eR, 0.0), quaternion(eU, 0.0)).xyz);\n}\n\n\nvoid main() {\n    UV = position;\n    float height = texture2D(heightTex, UV)[0];\n    vec4 position2 = scale*(vec4(UV - vec2(0.5, 0.5), 0.0, 0.0) \n                            + vec4(0.0, 0.0, -heightScale*height, 0.0));\n\n    // vec4 finalPosition = vec4(position2.xyz, 1.0);\n    vec4 finalPosition = rotate(position2, rotation) + vec4(translate, 0.0);\n\n    NORMAL = rotate(quaternion(-getNormal(UV), 1.0), conj(rotation)).xyz;\n    FINAL_VERTEX_POSITION = finalPosition.xyz;\n    gl_Position = project(finalPosition);\n}   `;
shaders[`./shaders/util/abs-xy.frag`] = `/* For each texel of the sample texture, interpret the\nfirst two channels as a two-component vector and output its length.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = vec4(length(texture2D(tex, UV).xy));\n}`;
shaders[`./shaders/util/abs2-xy.frag`] = `/* For each texel of the sample texture, interpret the\nfirst two channels as a two-component vector and output its length squared.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nvoid main() {\n    vec2 r = texture2D(tex, UV).xy;\n    fragColor = vec4(r.x*r.x + r.y*r.y);\n}\n\n\n`;
shaders[`./shaders/util/add2.frag`] = `/* Add two textures together */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nvoid main() {\n    fragColor = texture2D(tex1, UV) + texture2D(tex2, UV);\n}\n`;
shaders[`./shaders/util/blend2colors.frag`] = `/* Take the rgb values of two different textures and combine\nthe two together.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float scale1;\nuniform sampler2D tex1;\nuniform float scale2;\nuniform sampler2D tex2;\n\nvoid main() {\n    vec3 color1 = texture2D(tex1, UV).rgb;\n    vec3 color2 = texture2D(tex2, UV).rgb;\n    fragColor = vec4(scale1*abs(color1) + scale2*abs(color2), 1.0);\n}\n\n\n`;
shaders[`./shaders/util/copy-flip.frag`] = `/* Copy and flip the contents of a texture along the y-direction\n to the output texture */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = texture2D(tex, vec2(UV.x, 1.0 - UV.y));\n}\n`;
shaders[`./shaders/util/copy.frag`] = `/* Copy the contents of a texture to the output texture */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = texture2D(tex, UV);\n}\n`;
shaders[`./shaders/util/domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\nReferences:\n\nWikipedia - Domain coloring\nhttps://en.wikipedia.org/wiki/Domain_coloring\n\nWikipedia - Hue\nhttps://en.wikipedia.org/wiki/Hue\n\nhttps://en.wikipedia.org/wiki/Hue#/media/File:HSV-RGB-comparison.svg\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    vec3 color = brightness*length(z2)*argumentToColor(atan(z2.y, z2.x));\n    fragColor = vec4(color, 1.0);\n}\n`;
shaders[`./shaders/util/gray-scale.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\n\nvoid main() {\n    vec3 color = vec3(texture2D(tex, UV)[0] + offset);\n    fragColor \n        = vec4(max(min(brightness*color, maxBrightness), -maxBrightness),\n        1.0);\n}\n\n`;
shaders[`./shaders/util/mul.frag`] = `/* Do a component-wise multiplication of two textures. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nvoid main() {\n    fragColor = texture2D(tex1, UV)*texture2D(tex2, UV);\n}\n`;
shaders[`./shaders/util/sample3d.frag`] = `/* Sample and interpolate data points from the texture containing\nfrom a source texture that represents 3D data and write it to\nanother texture.*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform ivec3 destinationTexelDimensions3D;\nuniform ivec2 destinationTexelDimensions2D;\nuniform ivec3 sourceTexelDimensions3D;\nuniform ivec2 sourceTexelDimensions2D;\n\n\nvec2 to2DSourceTextureCoordinates(vec3 uvw) {\n    int width2D = sourceTexelDimensions2D[0];\n    int height2D = sourceTexelDimensions2D[1];\n    int width3D = sourceTexelDimensions3D[0];\n    int height3D = sourceTexelDimensions3D[1];\n    int length3D = sourceTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DDestinationTextureCoordinates(vec2 uv) {\n    int width3D = destinationTexelDimensions3D[0];\n    int height3D = destinationTexelDimensions3D[1];\n    int length3D = destinationTexelDimensions3D[2];\n    int width2D = destinationTexelDimensions2D[0];\n    int height2D = destinationTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(sourceTexelDimensions3D[0]);\n    float height3D = float(sourceTexelDimensions3D[1]);\n    float length3D = float(sourceTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DSourceTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DSourceTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DSourceTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DSourceTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DSourceTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DSourceTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DSourceTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DSourceTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvoid main() {\n    if (sourceTexelDimensions3D[0] <= destinationTexelDimensions3D[0] &&\n        sourceTexelDimensions3D[1] <= destinationTexelDimensions3D[1] &&\n        sourceTexelDimensions3D[2] <= destinationTexelDimensions3D[2]) {\n        fragColor = sample2DTextureAs3D(\n            tex, to3DDestinationTextureCoordinates(UV));\n    } else {\n        fragColor = texture2D(\n            tex,\n            to2DSourceTextureCoordinates(\n                to3DDestinationTextureCoordinates(UV)));\n    }\n    // fragColor = vec4(1.0);\n}\n`;
shaders[`./shaders/util/scale-rgba.frag`] = `/* Scale a texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform vec4 scale;\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = scale*texture2D(tex, UV);\n}\n`;
shaders[`./shaders/util/scale.frag`] = `/* Scale a texture. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform float scale;\nuniform sampler2D tex;\n\nvoid main() {\n    fragColor = scale*texture2D(tex, UV);\n}\n`;
shaders[`./shaders/util/slice-of-3d.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define XY_SLICE 0\n#define ZY_SLICE 1\n#define XZ_SLICE 2\nuniform int orientation;\nuniform int slice;\nuniform bool showAxis;\nuniform bool showOutline;\nuniform float alpha;\n\nuniform sampler2D tex;\nuniform ivec3 sourceTexelDimensions3D;\nuniform ivec2 sourceTexelDimensions2D;\n\n\nvec2 to2DSourceTextureCoordinates(vec3 uvw) {\n    int width2D = sourceTexelDimensions2D[0];\n    int height2D = sourceTexelDimensions2D[1];\n    int width3D = sourceTexelDimensions3D[0];\n    int height3D = sourceTexelDimensions3D[1];\n    int length3D = sourceTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(sourceTexelDimensions3D[0]);\n    float height3D = float(sourceTexelDimensions3D[1]);\n    float length3D = float(sourceTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DSourceTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DSourceTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DSourceTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DSourceTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DSourceTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DSourceTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DSourceTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DSourceTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvoid main() {\n    vec3 uvw;\n    if (orientation == XY_SLICE) {\n        float z = (float(slice) + 0.5)/float(sourceTexelDimensions3D[2]);\n        uvw = vec3(UV[0], UV[1], z);\n    } else if (orientation == ZY_SLICE) { \n        float x = (float(slice) + 0.5)/float(sourceTexelDimensions3D[0]);\n        uvw = vec3(x, UV[1], UV[0]);\n    } else if (orientation == XZ_SLICE) {\n        float y = (float(slice) + 0.5)/float(sourceTexelDimensions3D[1]);\n        uvw = vec3(UV[0], y, UV[1]);\n    }\n    // fragColor = vec4(1.0);\n    // fragColor = vec4(5.0*uv[0], 0.0, 0.0, 1.0);\n    fragColor = vec4(sample2DTextureAs3D(tex, uvw).rgb, alpha);\n    if (showAxis) {\n        if (abs(UV[0] - 0.5) < 1.0/float(sourceTexelDimensions2D[0]) ||\n            abs(UV[1] - 0.5) < 1.0/float(sourceTexelDimensions2D[1])) {\n            fragColor += vec4(1.0, 1.0, 1.0, 0.0);\n        }\n    }\n    if (showOutline) {\n        float d = 0.01;\n        float col = smoothstep(1.0 - d, 1.0, 1.0 - UV[0])\n                        + smoothstep(1.0 - d, 1.0, UV[0])\n                        + smoothstep(1.0 - d, 1.0, 1.0 - UV[1])\n                        + smoothstep(1.0 - d, 1.0, UV[1]);\n        fragColor += vec4(col);\n    }\n}`;
shaders[`./shaders/util/uniform-color.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform vec4 color;\n\nvoid main() {\n    fragColor = color;\n}`;
shaders[`./shaders/util/zero-boundaries-3d.frag`] = `/* For the 3D array data that's stored in the source texture,\n    set those values along the 3D array boundaries to zero. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform ivec2 texelDimensions2D;\nuniform ivec3 texelDimensions3D;\n\nuniform sampler2D tex;\n\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    vec3 uvw = to3DTextureCoordinates(UV);\n    vec3 dimensions3D = vec3(\n        float(texelDimensions3D[0]),\n        float(texelDimensions3D[1]),\n        float(texelDimensions3D[2])\n    );\n    vec4 texVal = texture2D(tex, UV);\n    if (uvw[0] < 1.0/dimensions3D[0] || \n        uvw[0] > (dimensions3D[0] - 1.0)/dimensions3D[0] ||\n        uvw[1] <  1.0/dimensions3D[1] || \n        uvw[1] > (dimensions3D[1] - 1.0)/dimensions3D[1] ||\n        uvw[2] <  1.0/dimensions3D[2] || \n        uvw[2] > (dimensions3D[2] - 1.0)/dimensions3D[2])\n        fragColor = vec4(0.0);\n    else\n        fragColor = texVal;\n}`;
shaders[`./shaders/vol-render/color-height-map1.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\n\nuniform int brightnessMode;\nconst int ABS_VAL_SQUARED = 2;\nconst int INV_ABS_VAL = -1;\n\n#define PI 3.141592653589793\n\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\n\nvoid main() {\n    float initVal = texture2D(tex, UV)[0];\n    float val;\n    if (brightnessMode == INV_ABS_VAL) {\n        val = brightness/initVal + brightness*offset - 1.0;\n    } else if (brightnessMode == ABS_VAL_SQUARED) {\n        val = brightness*(abs(initVal)*abs(initVal) + offset);\n    } else {\n        val = brightness*(abs(initVal) + offset);\n    }\n    float angle = -PI*val - 2.0*PI/3.0;\n    if (angle < -PI) {\n        angle = 2.0*PI + angle;\n        if (angle < 0.0) {\n            angle = 0.0;\n        }\n    }\n    vec3 visualVal = min(val/16.0, maxBrightness)*\n                        argumentToColor(angle);\n    fragColor = vec4(visualVal, length(visualVal));\n}`;
shaders[`./shaders/vol-render/cube-outline.vert`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nattribute vec3 position;\n#else\nin vec3 position;\n#endif\n\n#define quaternion vec4\n\nuniform float viewScale;\nuniform vec4 rotation;\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return vec4(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvoid main() {\n    vec3 r = rotate(quaternion(position, 1.0), \n                    rotation).xyz*viewScale;\n    gl_Position = vec4(r, 1.0);\n}\n`;
shaders[`./shaders/vol-render/display.frag`] = `/* The variable UV from the previous vertex shading step contains \nthe 2D texture coordinate representation of the volume render.\nIt is in 2D because the gradient and density are stored in 2D textures.\nThese sampled gradient and density data points are combined to determine\nhow the pixel should be displayed.\n\nThis corresponds to the shading step as given on the Wikipedia\npage for Volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform vec4 rotation;\nuniform sampler2D gradientTex;\nuniform sampler2D densityTex;\n\nuniform ivec3 fragmentTexelDimensions3D;\nuniform ivec2 fragmentTexelDimensions2D;\nuniform float alphaBrightness;\nuniform float colorBrightness;\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec2 to2DTextureCoordinates(vec3 uvw) {\n    int width2D = fragmentTexelDimensions2D[0];\n    int height2D = fragmentTexelDimensions2D[1];\n    int width3D = fragmentTexelDimensions3D[0];\n    int height3D = fragmentTexelDimensions3D[1];\n    int length3D = fragmentTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = fragmentTexelDimensions3D[0];\n    int height3D = fragmentTexelDimensions3D[1];\n    int length3D = fragmentTexelDimensions3D[2];\n    int width2D = fragmentTexelDimensions2D[0];\n    int height2D = fragmentTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n\n// void main() {\n//     vec3 r = to3DTextureCoordinates(UV);\n//     vec2 uv2 = to2DTextureCoordinates(r);\n//     fragColor = vec4(r.z, r.z, r.z, length(r));\n// }\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(fragmentTexelDimensions3D[0]);\n    float height3D = float(fragmentTexelDimensions3D[1]);\n    float length3D = float(fragmentTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvec4 averageOutZSlice(sampler2D tex, vec3 r, vec3 dz) {\n    ivec3 texelDimensions3D = fragmentTexelDimensions3D;\n    vec3 dx = vec3(1.0/float(texelDimensions3D[0]), 0.0, 0.0);\n    vec3 dy = vec3(0.0, 1.0/float(texelDimensions3D[1]), 0.0);\n    vec4 vCC = texture2D(tex, to2DTextureCoordinates(r + dz));\n    vec4 vRC = texture2D(tex, to2DTextureCoordinates(r + dx + dz));\n    vec4 vRU = texture2D(tex, \n        to2DTextureCoordinates(r + dx + dy + dz));\n    vec4 vCU = texture2D(tex, to2DTextureCoordinates(r + dy + dz));\n    vec4 vLU = texture2D(tex,\n        to2DTextureCoordinates(r - dx + dy + dz));\n    vec4 vLC = texture2D(tex, to2DTextureCoordinates(r - dx + dz));\n    vec4 vLD = texture2D(tex,\n        to2DTextureCoordinates(r - dx - dy + dz));\n    vec4 vCD = texture2D(tex, to2DTextureCoordinates(r - dy + dz));\n    vec4 vRD = texture2D(tex,\n        to2DTextureCoordinates(r + dx - dy + dz));\n    return (vCC + vRC + vRU + vCU + vLU + vLC + vLD + vCD + vRD)/9.0;\n}\n\nvec4 averageOut(sampler2D tex, vec3 r) {\n    ivec3 texelDimensions3D = fragmentTexelDimensions3D;\n    vec3 dz = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    vec4 vC = averageOutZSlice(tex, r, vec3(0.0));\n    vec4 vF = averageOutZSlice(tex, r, dz);\n    vec4 vB = averageOutZSlice(tex, r, -dz);\n    return (vC + vF + vB)/3.0;\n}\n\nvec4 gaussianFilter3x3x3(sampler2D tex, vec3 r)\n{\n    ivec3 texelDimensions3D = fragmentTexelDimensions3D;\n    vec3 dx = vec3(1.0/float(texelDimensions3D[0]), 0.0, 0.0);\n    vec3 dy = vec3(0.0, 1.0/float(texelDimensions3D[1]), 0.0);\n    vec3 dz = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    vec4 g = vec4(0.0);\n    g += 0.009658879892818452*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (-1.0)*dy + (-1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (-1.0)*dy + (-1.0)*dz));\n    g += 0.009658879892818452*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (-1.0)*dy + (-1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (0.0)*dy + (-1.0)*dz));\n    g += 0.015064216041401318*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (0.0)*dy + (-1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (0.0)*dy + (-1.0)*dz));\n    g += 0.009658879892818452*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (1.0)*dy + (-1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (1.0)*dy + (-1.0)*dz));\n    g += 0.009658879892818452*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (1.0)*dy + (-1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (-1.0)*dy + (0.0)*dz));\n    g += 0.015064216041401318*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (-1.0)*dy + (0.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (-1.0)*dy + (0.0)*dz));\n    g += 0.01506421604140132*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (0.0)*dy + (0.0)*dz));\n    g += 0.018812929165701035*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (0.0)*dy + (0.0)*dz));\n    g += 0.01506421604140132*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (0.0)*dy + (0.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (1.0)*dy + (0.0)*dz));\n    g += 0.015064216041401318*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (1.0)*dy + (0.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (1.0)*dy + (0.0)*dz));\n    g += 0.009658879892818452*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (-1.0)*dy + (1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (-1.0)*dy + (1.0)*dz));\n    g += 0.009658879892818452*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (-1.0)*dy + (1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (0.0)*dy + (1.0)*dz));\n    g += 0.015064216041401318*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (0.0)*dy + (1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (0.0)*dy + (1.0)*dz));\n    g += 0.009658879892818452*texture2D(tex, \n        to2DTextureCoordinates(r + (-1.0)*dx + (1.0)*dy + (1.0)*dz));\n    g += 0.012062481229969411*texture2D(tex, \n        to2DTextureCoordinates(r + (0.0)*dx + (1.0)*dy + (1.0)*dz));\n    g += 0.009658879892818452*texture2D(tex, \n        to2DTextureCoordinates(r + (1.0)*dx + (1.0)*dy + (1.0)*dz));\n    return g;\n}\n\nvec4 averageOutZDir(sampler2D tex, vec3 r) {\n    ivec3 texelDimensions3D = fragmentTexelDimensions3D;\n    vec3 dz = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    vec4 vB4 = texture2D(tex, to2DTextureCoordinates(r - 4.0*dz));\n    vec4 vB3 = texture2D(tex, to2DTextureCoordinates(r - 3.0*dz));\n    vec4 vB2 = texture2D(tex, to2DTextureCoordinates(r - 2.0*dz));\n    vec4 vB1 = texture2D(tex, to2DTextureCoordinates(r - dz));\n    vec4 vF0 = texture2D(tex, to2DTextureCoordinates(r));\n    vec4 vF1 = texture2D(tex, to2DTextureCoordinates(r + dz));\n    vec4 vF2 = texture2D(tex, to2DTextureCoordinates(r + 2.0*dz));\n    vec4 vF3 = texture2D(tex, to2DTextureCoordinates(r + 3.0*dz));\n    vec4 vF4 = texture2D(tex, to2DTextureCoordinates(r + 4.0*dz));\n    return (vF4 + vF3 + vF2 + vF1 + vF0 + vB1 + vB2 + vB3 + vB4)/9.0;\n}\n\nvec4 gaussianZDir(sampler2D tex, vec3 r) {\n    ivec3 texelDimensions3D = fragmentTexelDimensions3D;\n    vec3 dz = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    // vec4 vB4 = texture2D(tex, to2DTextureCoordinates(r - 4.0*dz));\n    vec4 vB3 = texture2D(tex, to2DTextureCoordinates(r - 3.0*dz));\n    vec4 vB2 = texture2D(tex, to2DTextureCoordinates(r - 2.0*dz));\n    vec4 vB1 = texture2D(tex, to2DTextureCoordinates(r - dz));\n    vec4 vF0 = texture2D(tex, to2DTextureCoordinates(r));\n    vec4 vF1 = texture2D(tex, to2DTextureCoordinates(r + dz));\n    vec4 vF2 = texture2D(tex, to2DTextureCoordinates(r + 2.0*dz));\n    vec4 vF3 = texture2D(tex, to2DTextureCoordinates(r + 3.0*dz));\n    // vec4 vF4 = texture2D(tex, to2DTextureCoordinates(r + 4.0*dz));\n    float wF0 = 0.26596152, wF1 = 0.21296534;\n    float wF2 = 0.10934005, wF3 = 0.03599398;\n    return (wF3*vF3 + wF2*vF2 + wF1*vF1 + wF0*vF0 \n            + wF1*vB1 + wF2*vB2 + wF3*vB3);\n}\n\nvec4 laplacian(sampler2D tex, vec4 vc, vec3 r) {\n    ivec3 texelDimensions3D = fragmentTexelDimensions3D;\n    vec3 dx = vec3(1.0/float(texelDimensions3D[0]), 0.0, 0.0);\n    vec3 dy = vec3(0.0, 1.0/float(texelDimensions3D[1]), 0.0);\n    vec3 dz = vec3(0.0, 0.0, 1.0/float(texelDimensions3D[2]));\n    vec2 zF = to2DTextureCoordinates(r + dz);\n    vec2 zB = to2DTextureCoordinates(r - dz);\n    vec2 xF = to2DTextureCoordinates(r + dx);\n    vec2 xB = to2DTextureCoordinates(r - dx);\n    vec2 yF = to2DTextureCoordinates(r + dy);\n    vec2 yB = to2DTextureCoordinates(r - dy);\n    vec4 vzF = texture2D(tex, zF);\n    vec4 vzB = texture2D(tex, zB);\n    vec4 vxF = texture2D(tex, xF);\n    vec4 vxB = texture2D(tex, xB);\n    vec4 vyF = texture2D(tex, yF);\n    vec4 vyB = texture2D(tex, yB);\n    return (vzF + vzB - 2.0*vc)/(dx[0]*dx[0]) \n            + (vyF + vyB - 2.0*vc)/(dy[1]*dy[1]) \n            + (vxF + vxB - 2.0*vc)/(dz[2]*dz[2]);\n}\n\nvoid main() {\n    vec3 r = to3DTextureCoordinates(UV);\n    vec2 uv2 = to2DTextureCoordinates(r);\n    \n    vec3 grad = texture2D(gradientTex, uv2).xyz;\n    vec4 density = texture2D(densityTex, uv2);\n    // density += 0.00001*laplacian(densityTex, density, r);\n\n    // vec4 density = averageOutZSlice(densityTex, r, vec3(0.0, 0.0, 0.0));\n\n    // vec4 density = gaussianFilter3x3x3(densityTex, r);\n    // vec3 grad = gaussianFilter3x3x3(gradientTex, r).xyz;\n    // vec4 density = gaussianZDir(densityTex, r);\n\n    // vec3 grad = averageOutZDir(gradientTex, r).xyz;\n    // vec4 density = averageOutZDir(densityTex, r);\n\n    // vec3 grad = averageOut(gradientTex, r).xyz;\n    // vec4 density = averageOut(densityTex, r);\n\n    // vec3 grad = sample2DTextureAs3D(gradientTex, r).xyz;\n    // vec4 density = sample2DTextureAs3D(densityTex, r);\n    vec3 normal = rotate(quaternion(0.0, 0.0, 1.0, 1.0),\n                         conj(rotation)).xyz;\n    vec4 pix = density;\n    \n    // pix.a = pix.b;\n    // lf (length(grad) < 0.0000001) discard;\n    if (pix.a < 0.05) discard;\n    if (dot(grad, grad) == 0.0) discard;\n    // fragColor = 4.0*pix;\n    float a = dot(normal, normalize(grad));\n    if (a <= 0.0) discard;\n    \n    // fragColor = vec4(1.0*normalize(density.rgb), a*a);\n    \n    // float densityLength = length(density.rgb);\n    // if (densityLength == 0.0) discard;\n    // fragColor = vec4(density.rgb/densityLength, a);\n    \n    fragColor = vec4(normalize(density.rgb)*colorBrightness, a*alphaBrightness);\n    \n    // fragColor = vec4(4.0*normalize(density.rgb), 0.1*a);\n    // fragColor = vec4(1.0);\n}`;
shaders[`./shaders/vol-render/display.vert`] = `/* The attribute or input uvIndex contains the 2D coordinates represetation\nof the volume render frame, which is then converted to 3D coordinates\nand manipulated using the other uniforms.\nIt is also directly passed to the fragment shader as the varying or\nout variable UV, so that it can be used to sample the volume data which\nis stored in a 2D texture format. */\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nattribute vec2 uvIndex;\nvarying vec2 UV;\n#else\nin vec2 uvIndex;\nout vec2 UV;\n#endif\n\n#define quaternion vec4\n\nuniform vec4 debugRotation;\nuniform bool debugShow2DTexture;\nuniform float scale;\n\nuniform ivec3 texelDimensions3D;\nuniform ivec2 texelDimensions2D;\n\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec4 project(vec4 x) {\n    return vec4(x.x, x.y, 0.0, 1.0);\n    /* vec4 y;\n    y[0] = x[0]*5.0/(x[2] + 5.0);\n    y[1] = x[1]*5.0/(x[2] + 5.0);\n    y[2] = x[2];\n    y[3] = 1.0;\n    return y;*/\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = texelDimensions3D[0];\n    int height3D = texelDimensions3D[1];\n    int length3D = texelDimensions3D[2];\n    int width2D = texelDimensions2D[0];\n    int height2D = texelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\nvoid main() {\n    if (debugShow2DTexture) {\n        gl_Position = vec4(2.0*(uvIndex - vec2(0.5, 0.5)), 0.0, 1.0);\n        return;\n    }\n    UV = uvIndex.xy;\n    vec4 viewPos = vec4(to3DTextureCoordinates(UV), 1.0)\n                   - vec4(0.5, 0.5, 0.5, 0.0);\n    gl_Position = project(2.0*scale*rotate(viewPos, debugRotation));\n}\n`;
shaders[`./shaders/vol-render/domain-coloring.frag`] = `/* Interpret the first two channels of a texel as complex value\nand convert it to a colour\n\nReferences:\n\nWikipedia - Domain coloring\nhttps://en.wikipedia.org/wiki/Domain_coloring\n\nWikipedia - Hue\nhttps://en.wikipedia.org/wiki/Hue\n\nhttps://en.wikipedia.org/wiki/Hue#/media/File:HSV-RGB-comparison.svg\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n    \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define complex vec2\n\n#define PI 3.141592653589793\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float phaseAdjust;\n\nuniform int brightnessMode;\nconst int ABS_VAL = 1;\nconst int ABS_VAL_SQUARED = 2;\nconst int INV_ABS_VAL = -1;\n\ncomplex mul(complex w, complex z) {\n    return complex(w.x*z.x - w.y*z.y, w.x*z.y + w.y*z.x);\n}\n\nvec3 argumentToColor(float argVal) {\n    float maxCol = 1.0;\n    float minCol = 50.0/255.0;\n    float colRange = maxCol - minCol;\n    if (argVal <= PI/3.0 && argVal >= 0.0) {\n        return vec3(maxCol,\n                    minCol + colRange*argVal/(PI/3.0), minCol);\n    } else if (argVal > PI/3.0 && argVal <= 2.0*PI/3.0){\n        return vec3(maxCol - colRange*(argVal - PI/3.0)/(PI/3.0),\n                    maxCol, minCol);\n    } else if (argVal > 2.0*PI/3.0 && argVal <= PI){\n        return vec3(minCol, maxCol,\n                    minCol + colRange*(argVal - 2.0*PI/3.0)/(PI/3.0));\n    } else if (argVal < 0.0 && argVal > -PI/3.0){\n        return vec3(maxCol, minCol,\n                    minCol - colRange*argVal/(PI/3.0));\n    } else if (argVal <= -PI/3.0 && argVal > -2.0*PI/3.0){\n        return vec3(maxCol + (colRange*(argVal + PI/3.0)/(PI/3.0)),\n                    minCol, maxCol);\n    } else if (argVal <= -2.0*PI/3.0 && argVal >= -PI){\n        return vec3(minCol,\n                    minCol - (colRange*(argVal + 2.0*PI/3.0)/(PI/3.0)), \n                    maxCol);\n    }\n    else {\n        return vec3(minCol, maxCol, maxCol);\n    }\n}\n\nvoid main() {\n    complex z1 = texture2D(tex, UV).xy;\n    complex phaseFactor = complex(cos(phaseAdjust), sin(phaseAdjust));\n    complex z2 = mul(phaseFactor, z1);\n    vec3 color = argumentToColor(atan(z2.y, z2.x));\n    fragColor = vec4(brightness*length(z2)*color, brightness*length(z2));\n    float brightness2;\n    if (brightnessMode == ABS_VAL_SQUARED) {\n        brightness2 = brightness*length(z2)*length(z2);\n    } else if (brightnessMode == INV_ABS_VAL) {\n        brightness2 = brightness/(length(z2)) - 1.0;\n    } else {\n        brightness2 = brightness*length(z2);\n    }\n    fragColor = vec4(brightness2*color, brightness2);\n}\n`;
shaders[`./shaders/vol-render/gray-scale.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\n\nuniform int brightnessMode;\nconst int ABS_VAL_SQUARED = 2;\nconst int INV_ABS_VAL = -1;\n\nvoid main() {\n    float initVal = texture2D(tex, UV)[0];\n    float val;\n    if (brightnessMode == INV_ABS_VAL) {\n        val = 1.0/abs(initVal) + offset - 1.0;\n    } else if (brightnessMode == ABS_VAL_SQUARED) {\n        val = abs(initVal)*abs(initVal) + offset;\n    } else {\n        val = initVal + offset;\n    }\n    vec3 color = vec3(val);\n    fragColor \n        = vec4(max(min(brightness*color, maxBrightness), -maxBrightness),\n               max(min(brightness*val, maxBrightness), -maxBrightness));\n}\n\n`;
shaders[`./shaders/vol-render/sample-display.frag`] = `/* The variable UV from the previous vertex shading step contains \nthe 2D texture coordinate representation of the volume render.\nIt is in 2D because the gradient and density are stored in 2D textures.\nThese sampled gradient and density data points are combined to determine\nhow the pixel should be displayed.\n\nThis corresponds to the shading step as given on the Wikipedia\npage for Volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform float viewScale;\n\nuniform vec4 rotation;\nuniform sampler2D gradientTex;\nuniform sampler2D densityTex;\n\nuniform ivec3 sampleTexelDimensions3D;\nuniform ivec2 sampleTexelDimensions2D;\nuniform ivec3 viewTexelDimensions3D;\nuniform ivec2 viewTexelDimensions2D;\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return quaternion(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\n/* Sample and interpolate data points from the texture containing the \ninitial raw 3D volumetric data to points on volume render frame.\nThis corresponds to the sampling step given in the Wikipedia page\nfor volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n\nvec2 to2DSampleTextureCoordinates(vec3 uvw) {\n    int width2D = sampleTexelDimensions2D[0];\n    int height2D = sampleTexelDimensions2D[1];\n    int width3D = sampleTexelDimensions3D[0];\n    int height3D = sampleTexelDimensions3D[1];\n    int length3D = sampleTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\n\n// bilinear interpolation\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(sampleTexelDimensions3D[0]);\n    float height3D = float(sampleTexelDimensions3D[1]);\n    float length3D = float(sampleTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DSampleTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DSampleTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DSampleTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DSampleTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DSampleTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DSampleTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DSampleTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DSampleTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvec3 to3DTextureCoordinates(vec2 uv) {\n    int width3D = viewTexelDimensions3D[0];\n    int height3D = viewTexelDimensions3D[1];\n    int length3D = viewTexelDimensions3D[2];\n    int width2D = viewTexelDimensions2D[0];\n    int height2D = viewTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n\nvoid main() {\n    // float viewScaleAdj = max(viewScale, 2.0);\n    vec3 r = to3DTextureCoordinates(UV);\n    vec3 rSampler = rotate(quaternion(r - vec3(0.5), 1.0), \n                           conj(rotation)).xyz/viewScale + vec3(0.5);\n\n    // This check needs to be done to avoid a repeating effect\n    // caused by sampling beyond the initial boundary.\n    if (rSampler.x < 0.0 || rSampler.x >= 1.0 ||\n        rSampler.y < 0.0 || rSampler.y >= 1.0 ||\n        rSampler.z < 0.0 || rSampler.z >= 1.0) \n        discard;\n\n    vec3 grad = sample2DTextureAs3D(gradientTex, rSampler).xyz;\n    vec4 density = sample2DTextureAs3D(densityTex, rSampler);\n    if (density.a < 0.05)\n        discard;\n    if (dot(grad, grad) == 0.0)\n        discard;\n\n    vec3 normal = rotate(quaternion(0.0, 0.0, 1.0, 1.0),\n                         conj(rotation)).xyz;\n    float a = dot(normal, normalize(grad));\n    if (a <= 0.0)\n        discard;\n    fragColor = vec4(normalize(density.rgb), 0.1*a);\n}`;
shaders[`./shaders/vol-render/sample.frag`] = `/* Sample and interpolate data points from the texture containing the \ninitial raw 3D data to points on volume render frame.\nThis corresponds to the sampling step given in the Wikipedia page\nfor volume ray casting.\n\nReferences:\n\nVolume ray casting - Wikipedia\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n*/\n#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n \n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\n#define quaternion vec4\n\nuniform sampler2D tex;\nuniform float viewScale;\nuniform vec4 rotation;\nuniform ivec3 volumeTexelDimensions3D;\nuniform ivec2 volumeTexelDimensions2D;\nuniform ivec3 dataTexelDimensions3D;\nuniform ivec2 dataTexelDimensions2D;\n\nquaternion mul(quaternion q1, quaternion q2) {\n    quaternion q3;\n    q3.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n    q3.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y; \n    q3.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z; \n    q3.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n    return q3; \n}\n\nquaternion conj(quaternion r) {\n    return vec4(-r.x, -r.y, -r.z, r.w);\n}\n\nquaternion rotate(quaternion x, quaternion r) {\n    quaternion xr = mul(x, r);\n    quaternion rInv = conj(r);\n    quaternion x2 = mul(rInv, xr);\n    x2.w = 1.0;\n    return x2; \n}\n\nvec2 to2DDataTextureCoordinates(vec3 uvw) {\n    int width2D = dataTexelDimensions2D[0];\n    int height2D = dataTexelDimensions2D[1];\n    int width3D = dataTexelDimensions3D[0];\n    int height3D = dataTexelDimensions3D[1];\n    int length3D = dataTexelDimensions3D[2];\n    float wStack = float(width2D)/float(width3D);\n    // float hStack = float(height2D)/float(height3D);\n    float xIndex = float(width3D)*mod(uvw[0], 1.0);\n    float yIndex = float(height3D)*mod(uvw[1], 1.0);\n    float zIndex = mod(floor(float(length3D)*uvw[2]), float(length3D));\n    float uIndex = mod(zIndex, wStack)*float(width3D) + xIndex; \n    float vIndex = floor(zIndex / wStack)*float(height3D) + yIndex; \n    return vec2(uIndex/float(width2D), vIndex/float(height2D));\n}\n\nvec3 to3DVolumeTextureCoordinates(vec2 uv) {\n    int width3D = volumeTexelDimensions3D[0];\n    int height3D = volumeTexelDimensions3D[1];\n    int length3D = volumeTexelDimensions3D[2];\n    int width2D = volumeTexelDimensions2D[0];\n    int height2D = volumeTexelDimensions2D[1];\n    float wStack = float(width2D)/float(width3D);\n    float hStack = float(height2D)/float(height3D);\n    float u = mod(uv[0]*wStack, 1.0);\n    float v = mod(uv[1]*hStack, 1.0);\n    float w = (floor(uv[1]*hStack)*wStack\n               + floor(uv[0]*wStack) + 0.5)/float(length3D);\n    return vec3(u, v, w);\n}\n\n/* Bilinear interpolation */\nvec4 blI(vec2 r, float x0, float y0, float x1, float y1,\n         vec4 w00, vec4 w10, vec4 w01, vec4 w11) {\n    float dx = x1 - x0, dy = y1 - y0;\n    float ax = (dx == 0.0)? 0.0: (r.x - x0)/dx;\n    float ay = (dy == 0.0)? 0.0: (r.y - y0)/dy;\n    return mix(mix(w00, w10, ax), mix(w01, w11, ax), ay);\n}\n\n/*\nCurrently this assumes that the texture being sampled from\nis smaller for all dimensions than the texture being\nrendered to.\n*/\nvec4 sample2DTextureAs3D(sampler2D tex, vec3 position) {\n    vec3 r = position;\n    float width3D = float(dataTexelDimensions3D[0]);\n    float height3D = float(dataTexelDimensions3D[1]);\n    float length3D = float(dataTexelDimensions3D[2]);\n    float x0 = (floor(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y0 = (floor(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z0 = (floor(r.z*length3D - 0.5) + 0.5)/length3D;\n    float x1 = (ceil(r.x*width3D - 0.5) + 0.5)/width3D;\n    float y1 = (ceil(r.y*height3D - 0.5) + 0.5)/height3D;\n    float z1 = (ceil(r.z*length3D - 0.5) + 0.5)/length3D;\n    vec3 r000 = vec3(x0, y0, z0);\n    vec3 r100 = vec3(x1, y0, z0);\n    vec3 r010 = vec3(x0, y1, z0);\n    vec3 r001 = vec3(x0, y0, z1);\n    vec3 r110 = vec3(x1, y1, z0);\n    vec3 r101 = vec3(x1, y0, z1);\n    vec3 r011 = vec3(x0, y1, z1);\n    vec3 r111 = vec3(x1, y1, z1);\n    vec4 f000 = texture2D(tex, to2DDataTextureCoordinates(r000));\n    vec4 f100 = texture2D(tex, to2DDataTextureCoordinates(r100));\n    vec4 f010 = texture2D(tex, to2DDataTextureCoordinates(r010));\n    vec4 f001 = texture2D(tex, to2DDataTextureCoordinates(r001));\n    vec4 f110 = texture2D(tex, to2DDataTextureCoordinates(r110));\n    vec4 f101 = texture2D(tex, to2DDataTextureCoordinates(r101));\n    vec4 f011 = texture2D(tex, to2DDataTextureCoordinates(r011));\n    vec4 f111 = texture2D(tex, to2DDataTextureCoordinates(r111));\n    vec4 f0 = blI(r.xy, x0, y0, x1, y1, f000, f100, f010, f110);\n    vec4 f1 = blI(r.xy, x0, y0, x1, y1, f001, f101, f011, f111);\n    // Originally I made a mistake with the interpolation\n    // where I neglected to consider the edge case of sampling a point at\n    // at z0 (or x0 or y0) which resulted in a zero denominator for\n    // some calculations. This created black spots in the final render.\n    float dz = z1 - z0;\n    return mix(f0, f1, (dz == 0.0)? 0.0: (r.z - z0)/dz);\n}\n\nvoid main() {\n    vec4 viewPosition \n        = vec4(to3DVolumeTextureCoordinates(UV) - vec3(0.5), 1.0);\n    // float viewScaleAdj = max(viewScale, 2.0);\n    float viewScaleAdj = viewScale;\n    vec3 r = rotate(viewPosition, conj(rotation)).xyz/viewScaleAdj\n         + vec3(0.5);\n    // This check needs to be done to avoid a repeating effect\n    // caused by sampling beyond the initial boundary.\n    if (r.x < 0.0 || r.x >= 1.0 ||\n        r.y < 0.0 || r.y >= 1.0 ||\n        r.z < 0.0 || r.z >= 1.0) discard;\n    fragColor = sample2DTextureAs3D(tex, r);\n    // fragColor = vec4(1.0);\n}\n`;
shaders[`./shaders/vol-render/uniform-color-scale.frag`] = `#if (__VERSION__ >= 330) || (defined(GL_ES) && __VERSION__ >= 300)\n#define texture2D texture\n#else\n#define texture texture2D\n#endif\n\n#if (__VERSION__ > 120) || defined(GL_ES)\nprecision highp float;\n#endif\n\n#if __VERSION__ <= 120\nvarying vec2 UV;\n#define fragColor gl_FragColor\n#else\nin vec2 UV;\nout vec4 fragColor;\n#endif\n\nuniform sampler2D tex;\nuniform float brightness;\nuniform float offset;\nuniform float maxBrightness;\nuniform vec4 color;\n\nuniform int brightnessMode;\nconst int ABS_VAL_SQUARED = 2;\nconst int INV_ABS_VAL = -1;\n\nvoid main() {\n    float initVal = texture2D(tex, UV)[0];\n    float val;\n    if (brightnessMode == INV_ABS_VAL) {\n        val = brightness/initVal + brightness*offset - 1.0;\n    } else if (brightnessMode == ABS_VAL_SQUARED) {\n        val = brightness*(abs(initVal)*abs(initVal) + offset);\n    } else {\n        val = brightness*(abs(initVal) + offset);\n    }\n    fragColor \n        = vec4(max(min(val*color.rgb, maxBrightness),\n                 -maxBrightness),\n               max(min(val*color.a, maxBrightness), \n               -maxBrightness));\n}\n\n`;
const SHADERS = shaders;
export default SHADERS;
export const getShader = name => {console.log(`Getting ${name}.`); return SHADERS[name];}
