<!DOCTYPE html>
<meta charset="utf-8"/>
<html>
	<head>
        <style>
            h2 {font-family:Arial, Helvetica, sans-serif; }
            label {font-family:Arial, Helvetica, sans-serif; }
			text {font-family:Arial, Helvetica, sans-serif; }
        </style>
    </head>
	<body style="background-color: rgb(255, 255, 255);">
        <div></div>
        <div>
            <canvas style="
                            touch-action: none; background-color: rgb(50, 50, 50);
                           text-align: center;"
                id="sketchCanvas"></canvas>
        </div>
    </body>

<script type="module">

import gCanvas from "./canvas.js";
import { gl, gMainRenderWindow, Quad, Vec4, IVec2, IVec3, Vec3, Quaternion,
    TrianglesFrame, RenderTarget, Attribute, mul,
    makeProgramFromSources, withConfig,
    TextureParams, MultidimensionalDataQuad} from "./gl-wrappers.js";
import { getShader } from "./shaders.js";
import { fft3D, ifft3D } from "./fft3d.js";
import { 
    getVerticesAndElements, VolumeRender } from "./volume-render.js";

let uniformColorProgram = Quad.makeProgramFromSource(
    getShader('./shaders/util/uniform-color.frag')
);
let wavePacketProgram = Quad.makeProgramFromSource(
    getShader('./shaders/init-wavepacket/gaussian3d.frag')
);
let scaleProgram = Quad.makeProgramFromSource(
    getShader('./shaders/util/scale.frag')
);
let dimensions2D = new IVec2(512, 512);
let dimensions3D = new IVec3(64, 64, 64);
let viewDimensions = new IVec2(gCanvas.height, gCanvas.height);
let renderDimensions = new IVec3(128, 128, 128);
let volRender = new VolumeRender(viewDimensions, renderDimensions);
let [vertices, elements] = getVerticesAndElements(
    dimensions2D, dimensions3D
);
let triangles = new TrianglesFrame(
    {"uvIndex": new Attribute(2, gl.FLOAT, false)},
    vertices, elements);
let renderTarget = new RenderTarget(
    new TextureParams(
        gl.RGBA32F, gCanvas.height, gCanvas.height,
        true, gl.REPEAT, gl.REPEAT, gl.LINEAR, gl.LINEAR
    )
);
let f = new MultidimensionalDataQuad([64, 64, 64],
    new TextureParams(
        gl.RGBA32F, 512, 512, true,
        gl.REPEAT, gl.REPEAT, 
        gl.LINEAR, gl.LINEAR)
);
let f2 = new MultidimensionalDataQuad([64, 64, 64],
    new TextureParams(
        gl.RGBA32F, 512, 512, true,
        gl.REPEAT, gl.REPEAT, 
        gl.LINEAR, gl.LINEAR)
);
let f3 = new MultidimensionalDataQuad([64, 64, 64],
    new TextureParams(
        gl.RGBA32F, 512, 512, true,
        gl.REPEAT, gl.REPEAT, 
        gl.LINEAR, gl.LINEAR)
);
console.log('f instance of quad: ', f instanceof Quad);

let renderProgram = makeProgramFromSources(
    getShader("./shaders/vol-render/display.vert"),
    // getShader("./shaders/vol-render/display.frag"),
    getShader("./shaders/util/uniform-color.frag")
);
let copyProgram = Quad.makeProgramFromSource(
    getShader("./shaders/util/copy.frag")
);

let gTime = 0.0;
let gRotation = Quaternion.rotator(Math.PI/4.0, 0.0, 0.0, 1.0);
let gMousePosition = [];


function setRotation(x0, y0, x1, y1) {
    let d = new Vec3(x1 - x0, y1 - y0, 0.0);
    let axis = Vec3.crossProd(d, new Vec3(0.0, 0.0, -1.0));
    let angle = 10.0*Math.sqrt(d.x*d.x + d.y*d.y + d.z*d.z);
    // console.log(angle, '\naxis: ', axis.x, axis.y, 
    //             '\nquaternion: ', gRotation);
    let rot = Quaternion.rotator(angle, axis.x, axis.y, axis.z);
    gRotation = mul(gRotation, rot);  
}

function getMouseXY(e) {
    let x = (e.clientX - gCanvas.offsetLeft)/gCanvas.width;
    let y = 1.0 - (e.clientY - gCanvas.offsetTop)/gCanvas.height;
    return [x, y];
}

function equalizeXYScaling(xy) {
    let canvasWidth = gCanvas.width;
    let canvasHeight = gCanvas.height;
    let x0 = xy[0], y0 = xy[1];
    if (canvasWidth >= canvasHeight) {
        let offset = ((canvasWidth - canvasHeight)/2.0)/canvasWidth;
        let x1 = (x0 - offset)*canvasWidth/canvasHeight;
        return [x1, y0];
    }
    else {
        let offset = ((canvasHeight - canvasWidth)/2.0)/canvasHeight;
        let y1 = (y0 - offset)*canvasHeight/canvasWidth;
        return [x0, y1];
    }
}

gCanvas.addEventListener("mousemove", e => {
    if (e.buttons !== 0) {
        if (getMouseXY(e)[0] < 0.0 || getMouseXY(e)[0] > 1.0 ||
            getMouseXY(e)[1] < 0.0 || getMouseXY(e)[0] > 1.0) {
            return;
        }
        if (gMousePosition.length === 0) {
            gMousePosition = equalizeXYScaling(getMouseXY(e));
            return;
        }
        // console.log(gMousePosition);
        let [x1, y1] = equalizeXYScaling(getMouseXY(e));
        let [x0, y0] = gMousePosition;
        setRotation(x0, y0, x1, y1);
        gMousePosition = [x1, y1];
    }
});

function animate() {

    f.draw(
        wavePacketProgram,
        {
            amplitude: 1.0,
            waveNumber: new Vec3(0.0, 0.0, 0.0),
            texOffset: new Vec3(0.5, 0.5, 0.5),
            sigma: new Vec3(0.05, 0.06, 0.05),
            texelDimensions3D: new IVec3(...f.dataDimensions),
            texelDimensions2D: f.textureDimensions
        }
    );
    fft3D(f2, f);
    ifft3D(f3, f2);
    let view = volRender.view(f3, 1.0, gRotation);

    gMainRenderWindow.draw(
        scaleProgram,
        {tex: view, scale: 10.0},
        {viewport: [0.5*(gCanvas.width - gCanvas.height), 0.0,
                    gCanvas.height, gCanvas.height]}
    );
    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);

</script>


</html>